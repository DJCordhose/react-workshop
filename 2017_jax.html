<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>React Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
        .reveal pre code {
            max-height: 1000px !important;
        }

        .reveal section img {
            border:0;
            box-shadow:0 0 0 0
        }
        /*rgb(196, 215, 240)*/
        html.exkurs body {
            background: rgb(252, 220, 185) url("ai/es6-icon.png") no-repeat right bottom;
        }


    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h3>React Workshop - Vorbereitung</h3>
            <p>Falls noch nicht gemacht:</p>
            <ol style="font-size: 85%">
                <li><code>git clone https://github.com/nilshartmann/react-workshop.git</code></li>
                <li>Im geklonten Verzeichnis: <code>npm install</code>
                    <br><span  style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
                <li><code>npm start</code></li>
                <li>In neuem Terminal: in <code>code/workspace</code> wechseln</li>
                <li>Ausführen: <code>npm start</code></li>
                <li>Browser öffnen: <a href="http://localhost:8080" target="_blank">http://localhost:8080</a></li>
                <li>Wenn dort ein Hello-World-Text erscheint ist alles gut
            </ol>
            <p>Folien: Im geklonten Verzeichnis <code>2017_jax.html</code>
            </p>
        </section>
        <section>
            <h1>React Workshop</h1>
            <div style="float:left">

            <p>
                <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>

            </p>
            <p>
                <a href="http://zeigermann.eu" target="_blank">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose" target="_blank">@DJCordhose</a>
            </p>
            <p><a href="http://bit.ly/jax2017-react-workshop">http://bit.ly/jax2017-react-workshop</a></p>
                <p style="border-top: 2px solid darkgray;margin-top:25px;padding-top:25px;">
                    <a href="https://reactbuch.de" target="_blank">React Buch (https://reactbuch.de)</a></p>
                <p><a href="https://react-workshop.de" target="_blank">React Workshop (https://react-workshop.de)</a>
                </p>
            </div>
            <div style="float:right">
                    <img style="max-height:350px" src="images/reactbuch-de.png" />
                <p>

                </div>
        </section>

        <section>
            <h2>Werbung</h2>
            <p>Lust bekommen, React zu entwickeln?</p>
            <p>Wir stellen ein :-)</p>
            <a href="https://eos-technology.solutions/karriere" target="_blank">EOS Technology Solutions</a>
        </section>

        <section>
            <h2>Inhalt</h2>
            <ul>
                <li><a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
                <li><a href="#/t1">Teil I: React-Komponenten</a>
                <li><a href="#/t2">Teil II: Komponentenhierarchien</a>
                <li><a href="#/t3">Teil III: Remote-Calls gegen Server</a>
                <li><a href="#/t4">Teil IV: Testen von React Anwendungen (Überblick)</a>
                <li><a href="#/t5">Teil V: Integration mit 3rd-Party-Bibliotheken</a>
                <li><a href="#/t6">Teil VI: Client-seitiges Routing (Überblick)</a>
            </li>
            </ul>
        </section>

        <section id="example-app">
            <h2>Beispiel-Anwendung</h2>
            <a target="_blank" href="code/schritte/router-v4/public/index.html"><img src="images/greeting-app.png" style="border:0;box-shadow:0 0 0 0;max-width: 80%"/></a>
        </section>

        <section id="t0">
            <h1>Teil 0</h1>
            <h2>React-Einführung und Build-Prozess</h2>
        </section>

        <section id="react">
            <h2>React</h2>
            <ul>
                <li class="fragment">Framework für Facebook und viele andere
                <li class="fragment">Komponenten kapseln Template und Logik
                  <li class="fragment">Deklarativ
                <li class="fragment">Abstraktion vom DOM: <em>f(model) -> UI</em>
                <li class="fragment">Minimales API
                <li class="fragment">Ein-Weg-Data-Binding: Zustandsänderungen stellen Komponente <b>komplett</b> neu dar
                <li class="fragment">Kann im Browser und auf dem Server rendern
                <li class="fragment">wird für komplette Anwendung typischerweise mit weiteren Libs verwendet (Redux, Flux, Router, ...)
                <li class="fragment">viel Inspiration aus der funktionalen Ecke (Immutable, pure functions, stateless)
            </ul>
        </section>

        <section>
            <h3>React Komponenten</h3>
            <ul>
                <li class="fragment">Werden als ES6 Klasse oder Funktion implementiert
                <li class="fragment">Keine Templatesprache (stattdessen JavaScript)
                <li class="fragment">Templates können HTML-artige Syntax enthalten (JSX)
            </ul>
            <pre class="fragment"><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return &lt;h1 className='title'>Hello, World!&lt;/h1>
  }
}
</code></pre>
        </section>

        <section>
            <h3>Eine erste Komponente: Hello, World!</h3>
                <a target="_blank" href="code/schritte/0-hello_world/public/index.html">Demo</a>
        </section>

        <section data-state="exkurs">
            <h2>ES6-Referenz</h2>
            <p>ES6 Features werden vorgestellt, wo wir sie brauchen</p>
            <p><a href="http://exploringjs.com/es6/" target="_blank">
                http://exploringjs.com/es6/</a>
        </section>
        <section data-state="exkurs">
            <h3>ES6: Template Strings</h3>
            <p>Template Strings werden in Backticks (``) geschrieben und können Ausdrücke
                (in <code>${}</code>) enthalten:</p>

            <pre class="fragment"><code class="javascript" contenteditable>const name = "Susi";
const greeting = `Hello, ${name}`; // Hello, Susi

const four = `Two and two is: ${2+2}` // Two and two is: 4

const time = `The time is: ${new Date()}`); // The time is: ...
            </code></pre>
        </section>


        <section data-state="exkurs">
            <h3>ES6: Klassen</h3>
            <pre><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return `${this.name} codes in ${this.language}`;
    }
}</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
        </section>

        <section data-state="exkurs">
            <h3>ES6: Arrow Functions</h3>
            <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable>// Klammern können weggelassen werden, genau ein Parameter
// ebenso die geschweiften Klassen, wenn nur ein Statement:
const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
        </section>

                <section>
                    <h3>Hello World React</h3>
<pre><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return (&lt;div>
            &lt;input ref={input => this.input = input}
                   onChange={event => this.updateModel(event)}
                   value={this.state.greeting} />
            &lt;p>{this.state.greeting}, World&lt;/p>
            &lt;button
                onClick={() => this.reset()}>
                Clear
            &lt;/button>
        &lt;/div>);
  }</code></pre>
<pre class="fragment"><code contenteditable class="javascript">  constructor(props) {
    super(props);
    this.state = {greeting: this.props.greeting};
  }
  updateModel(event) {
    this.setState({greeting: event.target.value});
  }
  reset() {
    this.setState({greeting: ""});
    this.input.focus();
  }
}</code></pre>
                </section>

        <section>
                    <h3>Aufruf</h3>
<pre><code data-trim contenteditable>
// index.html
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
<pre class="fragment"><code data-trim contenteditable class="javascript">
// main.js
import React from 'react';
import ReactDOM from 'react-dom';

import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage greeting="Hello"/>, mountNode);
</code></pre>
                    <a target="_blank" href="code/schritte/0-hello_world/public/index.html">Run</a>
                </section>


    <section>
        <h2>Buildprozess</h2>
        <ul>
            <li>ES6- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <li>Typische Werkzeuge
                <ul><li>Babel (Compiler)
                    <li>Webpack (Bundler)
                    <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
                    </ul>
        </ul>
    </section>
     <section>
        <h2>Webpack und Babel</h2>
        <img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0"/>
    </section>
    <section>
        <h2>Webpack Development Server</h2>
            <ul>
                <li>Zum Ausführen der Anwendung wird ein Webserver benötigt</li>
                <li class="fragment">Für die Entwicklung <b>Webpack Dev Server</b>:
                <ul>
                    <li>...führt Webpack auf Basis der Projekt Webpack Konfiguration aus</li>
                    <li>...erzeugt Ausgabe in Memory (Performance)</li>
                    <li>...Hot Reloading: Automatische Aktualisierung nach Code Änderung</li>
                    <li>...React Hot Loader: Zustand bleibt nach Aktualisierung erhalten (Beta)</li>
                </ul>
                <li class="fragment"><code>npm start</code> in unserem Beispiel-Projekt</li>
            </ul>
    </section>
    <section>
          <h2>Übung 0: React Hello-World</h2>
          <h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
      </section>
      <section>
          <h3>Schritt #1: Tool-Chain starten (falls noch nicht gemacht)</h3>
          <p>Nutze für die Übungen das <code>workspace</code>-Verzeichnis in diesem Repository. Hier ist eine Tool-Chain mit Webpack und Babel vorbereitet</p>
          <ol style="font-size: 85%">
              <li><code>npm install</code> (auf oberster Ebene)
                  <br><span  style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
              <li><code>cd code/workspace</code>
              <li><code>npm start</code>
              <li>Öffne <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
              <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
          </ol>
      </section>
      <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <ul>
              <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel aus den Folien
              <li><em>Zusatzaufgabe: Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.</em>
              <ul>
                      <li>Alle Eingaben sollen in Großbuchstaben auftauchen
                      <li>Gib irgendeine Rückmeldung wenn die Eingabe erfolgreich gelöscht wurde
                  </ul>
            </li>
          </ul>
      </section>

        <section id="t1">
            <h1>Teil I</h1>
            <h2>React-Komponenten</h2>
            <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Referenz</h2>
            <p><a href="https://facebook.github.io/react/docs" target="_blank">
                https://facebook.github.io/react/docs
            </a>
            </p>
        </section>


        <section>
            <h3>Themen</h3>
            <ul>
                <li>Rendering
                <li>Properties und Zustand
                <li>Referenzen auf DOM-Elemente (Refs)
            </ul>
        </section>

            <section>
                <h3>React: Rendering</h3>
                <span class="fragment">
                <p><em>Jede React-Komponente braucht eine <code>render</code>-Methode:</em>
                <ul>
                    <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
                    <li>liefert genau ein Element (oder keins) zurück</li>
                    <li>kann HTML-artige JSX-Syntax nutzen</li>
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
                    </span>
        </section>
        <section>
            <h3>React: JSX</h3>
            <ul>
                <li style="font-size: 80%" class="fragment">Wird wie HTML hingeschrieben, inkl Attribute: <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre></li>
                <li style="font-size: 80%"  class="fragment">Attribute, die keine Strings sind, müssen in {} eingechlossen werden:
                    <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
                </li>
                <li style="font-size: 80%"  class="fragment">Kann pures JavaScript enthalten, eingeschlossen in {}:
                    <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()&lt;/h1>
                    </code></pre>
                </li>

                <li style="font-size: 80%"  class="fragment"><code>class</code>-Attribut heißt <code>className</code>:
                    <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
                </li>
                <li style="font-size: 80%"  class="fragment">CSS-Eigenschaften werden als Objekt übergeben in Camel-Case-Notation:
                    <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
                </li>
            </ul>
        </section>
           <section>
                <h3>React: Rendering #2</h3>
                <ul class="fragment">
                    <li>DOM-Events werden in React-Events verpackt
                    <li>React-Events haben weitgehend selbe API wie DOM-Events
                    <li>Es gibt keine automatische Bindung an Modelle (2-Wege Databinding)
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
               value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  updateModel(greeting) {
    this.setState({greeting});
  }
  // ...
}
</code></pre>
        </section>
        <section data-state="exkurs">
            <h3>ES6: Erweiterte Objekt-Literale</h3>
   <pre><code class="javascript" contenteditable>const name = 'Oma';
const person = {
    // ES5: name: name
    name
};
console.log(person.name); // Oma
   </code></pre>
        </section>


                    <section data-state="exkurs">
                        <h2>ES6: Module, Importe und Exporte</h2>
                    </section>
                    <section data-state="exkurs">
                        <h3>ES6: Export einer einzigen Klasse</h3>
   <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
   <pre><code class="javascript" contenteditable>// Person.js
// in einer Zeile zusammengefasst
export default class Person {
  // ...
}
   </code></pre>
                    </section>
                    <section data-state="exkurs">
                        <h3>ES6: Import</h3>
   <pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
                    </section>
                    <section data-state="exkurs">
                        <h3>ES6: Benannte Exporte</h3>
   <pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}

export showInfo = msg => window.alert(`Wichtige Info: ${msg}`);

// or
function displayInPage(text) { . . . }
const showInfo = ...;
export { displayInPage, showInfo };
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
<!--display('Hello, World');-->
   <!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
<!--util.displayInPage('Hello, World');-->
   <!--</code></pre>-->
                    </section>
        <!--<section>-->
                        <!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
                    <!--</section>-->

                    <!--<section>-->
                      <!--<h3>Tagged Template Literals</h3>-->
          <!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
         <!--Mini-DSLs: Template-Literals mit tag-->
    <!--</a>-->
    <!--</p>-->

   <!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
  <!--console.log(strings);-->
  <!--//[ '', ' codes in ', '.' ]-->
  <!--console.log(values);-->
  <!--//[ 'Oma', 'Haskell' ]-->
  <!--return 'whatever you want';-->
<!--}-->
<!--</code></pre>-->

   <!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
<!--console.log(expanded);-->
<!--//whatever you want-->
<!--</code></pre>-->

                    <!--</section>-->

                    <section data-state="exkurs">
                        <h3>ES6: Destructuring von Objekten</h3>
   <pre><code class="javascript" contenteditable>const person = {
  name: 'Olli',
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable>const {name, notThere} = person;
console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable>function someFunction({name, notThere}) {
  console.log(`name=${name}`);
  // name=Olli
  console.log(`notThere=${notThere}`);
  // notThere=undefined
}
someFunction(person);
</code></pre>
                    </section>
        <section>
            <h3>React: Properties und Zustand</h3>
            <ul class="fragment">
                <li><b>Properties</b> werden der Komponente von <b>außen</b> übergeben (und nicht verändert)</li>
                <li><b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
                <li>Beides sind Objekte mit Key-Value-Paaren</li>
                <li>Beide können an Unterkomponenten übergeben werden</li>
            </ul>
        </section>

        <section>
            <h3>Properties einer Komponente</h3>
            <ul class="fragment">
                <li>Properties werden über den Konstruktor in die Komponente hineingereicht</li>
                <li>Properties dürfen nicht verändert werden</li>
                <li>Zugriff über <code>this.props</code></li>
                <li><code>this.props.children</code> enthält Kind-Elemente</li>
            </ul>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
class TitleComponent extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
      return &lt;h1>{this.props.title}&lt;/h1>
    }
   // ...
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
  &lt;TitleComponent title='Hello World' />
</code></pre>

        </section>

        <section>
            <h3>Zustand einer Komponente</h3>
            <ul class="fragment">
                <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server</li>
                <li>Werte üblicherweise immutable</li>
                <li><b>Initialisieren</b> im Konstruktor mit <code>this.state={}</code>
                <li>Zustand <b>lesen</b> über <code>this.state</code>
                <li>Zustand <b>setzen</b> über <code>this.setState()</code>
                <ul><li><b>Achtung:</b> kein "reiner" Setter</li>
                    <li>Führt alten und neuen Zustand zusammen</li>
                    <li>Wird asynchron ausgeführt!</li>
                    <li><b>Löst erneutes rendern der <i>gesamten</i> Komponente aus</b></li>
                </ul>
            </ul>
            </section>

            <section>
                <h3>Beispiel: Zustand einer Komponente</h3>
<pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
        </section>
        <section>
            <h3>Render Zyklus</h3>
            <img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Virtual DOM</h3>
            <img src="images/virtual-dom.png" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>React: Referenzen auf nativen DOM</h3>
            <ul class="fragment">
                <li>Elementen kann eine Callback-Funktion <code>refs</code> übergeben werden
                <li class="fragment">Funktion wird nach dem Rendern mit Referenz auf DOM Element aufgerufen (oder <code>null</code>)
                <li class="fragment">Diese Referenz kann man z.B. als Member-Variable speichern
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
    render() {
        return (
            <div>
                &lt;input ref={input => this.input = input} />
                &lt;button
                    onClick={() => this.input.focus()}>
                    Focus
                &lt;/button>
            </div>);
    }
}
</code></pre>
        </section>

      <section>
          <h2>Übung 1: Detail-Ansicht für unsere Gruß-Anwendung</h2>
          <h3>Erzeuge eine Komponente mit der man einen Namen und eine Grußformel eingeben kann</h3>
      </section>
      <section>
          <h3>Schritte</h3>
          <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
          <ul>
              <li>benenne deine Komponente in <code>GreetingDetail</code> um
              <li>du brauchst zwei Eingabefelder, die <code>name</code> und <code>greeting</code> im Zustand der Komponente setzen
              <li><em>Zusatzaufgabe: Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand initialisieren</em>
          </ul>
      </section>


        <section id="t2">
            <h1>Teil II</h1>
            <h2>Komponentenhierarchien</h2>
            <h3>Komplette Anwendung aus Komponenten bauen</h3>
            <a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Thinking in React</h2>
            <p><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank">
                https://facebook.github.io/react/docs/thinking-in-react.html
            </a>
            </p>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>Komponenten als Funktion
                <li>Darstellung von Listen und Keys
                <li>Architektur-Idee: Controller-Komponente und View-Komponente
                <li>Durchreichen von Zustand und Callbacks
                <li>PropTypes
            </ul>
        </section>

            <section>
                <h3>Komponenten als Funktion</h3>
                <ul class="fragment">
                    <li>Komponente ist eine einfache Funktion</li>
                    <li>entspricht der <code>render</code>-Methode</li>
                    <li>Properties werden als Object per Parameter übergeben</li>
                    <li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
                    <li>Empfehlung: Funktionen statt Klassen verwenden (wenn möglich)</li>
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
import React from 'react';
export default function Greet(props) {
  return (
      <div>
          <h1>{props.greeting}</h1>
          <h2>{props.name}</h2>
      </div>
  );
}

// Verwendung:
&lt;Greet name="Susi" greeting="Hello" /&gt;

</code></pre></section>
                <section>
                    <h3>Komponenten als Funktion</h3>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Mit Destructuring
export default function Greet({greeting, name}) {
  return (
      <div>
          <h1>{greeting}</h1>
          <h2>{name}</h2>
      </div>
  );
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Als Arrow Function
const Greet = ({greeting, name}) => <div>
    <h1>{greeting}</h1>
    <h2>{name}</h2>
  </div>
}
export default Greet;
</code></pre>

        </section>

            <section>
                <h3>Listen und Keys</h3>
                <ul class="fragment">
                    <li>JSX bietet nichts für Listen
                    <li>Ausgabe typischerweise über <code>Array.map</code>
                    <li>Elemente einer Liste brauchen einen eindeutigen Key
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [{
    id: 0,
    name: 'Olli',
    greeting: 'Huhu'
},
{
    id: 1,
    name: 'Oma',
    greeting: 'Hallo'
}
];
const body = greetings.map(greeting =>
    &lt;tr key={greeting.id}>
        &lt;td>{greeting.name}</td>
        &lt;td>{greeting.greeting}</td>
    &lt;/tr>);
</code></pre>
        </section>

        <section>
            <h3>Komponenten in Hierarchien</h3>
            <p>Beispiel: Unsere Anwendung</p>
            <img src="ai/greeting-hierarchy-without-callbacks.png"/>
        </section>

        <section>
            <h3>Controller und Child-Views</h3>
            <!--<img src="smart-dumb.jpg">-->
            <!--<img src="smart-dumb.png">-->
            <img src="images/smart-dumb-w-label.png">
        </section>

        <section>
            <h3>Durchreichen vom Zustand und Callbacks</h3>
            <ul class="fragment">
                <li>Funktioniert beides über Properties
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        const {greetings} = this.state;
        return &lt;div>
                &lt;GreetingMaster greetings={greetings}
                    onAdd={() => this.setState({mode: MODE_DETAIL})} />
            &lt;/div>;
    }
    // ...
}
    </code></pre>
    </section>
    <section>
        <h3>Properties übergeben mit Object-Spread</h3>
        <ul class="fragment">
                <li>Übergibt <b>alle</b> Eigenschaften eines Objektes als individuelle Properties</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {


    render() {
        const greeting = { name: 'Klaus', greeting: 'Hello' };

        return &lt;GreetingDetail {...greeting} />

        // entspricht:
        // &lt;GreetingDetail name='Klaus' greeting='Hello' />
    }
}
        </code></pre>
    </section>

        <section>
            <h3>PropTypes</h3>
                <ul>
                    <li class="fragment">Eine Komponente kann deklarieren, welche Properties sie erwartet
                    <li class="fragment">Auch der Typ kann angegeben werden (<a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank">Mögliche Typen</a>)
                    <li class="fragment">Fehlende / falsche Properties führen zu Laufzeitfehlern
                    <li class="fragment">Ab React 15.5 eigenes npm modul: <a href="https://www.npmjs.com/package/prop-types" target="_blank"><code>prop-types</code></a></li>
                    <li class="fragment">Alternative: Typsystem (<a href="https://flow.org" target="_blank">Flow</a> oder <a href="https://typescriptlang.org" target="_blank">TypeScript</a>)
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component { . . . };

GreetingDetail.propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
};
</code></pre>
        </section>
        <section>
            <h3>PropTypes</h3>
            <p>Mit statischen Properties (<code>static</code> noch kein JS Standard!)</p>
            <pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component {
  static propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
  };

  render() { . . . }
};
            </code></pre>
        </section>
        <section>
            <h3>PropTypes</h3>
            <p>Für Komponenten als Funktionen</p>
            <pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

function HelloMessage(text) { . . . }
HelloMessage.propTypes = {
  text: PropTypes.string.isRequired
}
            </code></pre>
        </section>


        <section>
            <h2>Übung 2: Eine komplette Anwendung zusammen setzen</h2>
            <h3>Füge deinen bestehenden Detail-View (<code>GreetingDetail</code>) und einen Master-View über eine Controller-Komponente zusammen</h3>
        </section>
        <section>
            <h3>Schritte</h3>
            <ol>
                <li>kopiere das Material aus <code>code/material/2-hierarchy</code> in deinen src-Ordner
                <li>erweitere im <code>GreetingController</code> die render-Methode, so dass dein <code>GreetingDetail</code> angezeigt wird, wenn der Benutzer den Add-Button klickt:
                <ul>
                    <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
                    <li>übergib einen Callback der <code>addGreeting</code> nutzt
                </ul>
                <li>im deinem <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
                <br><span style="font-size:85%">(Du kannst dein <code>GreetingDetail</code> verwenden, oder die Vorlage code/material/2-hierarchy/src/_GreetingDetail.js verwenden)</span>

            </ol>
        </section>
        <section>
            <h3>Architektur Beispiel-Anwendung</h3>
            <img src="ai/greeting-hierarchy.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>
        <section>
            <h3>GreetingMaster</h3>
            <img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>
        <section>
            <h3>GreetingDetail</h3>
            <img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section id="t3">
            <h1>Teil III</h1>
            <h2>Remote-Calls gegen Server</h2>
            <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h3>Herausforderungen</h3>
            <ul>
                <li>Wie machen wir das Laden und Speichern technisch?
                <li>Wo steht der Code zum initialen Laden der Grüße?
                <li>Wo speichern wir?
                <li>Wie funktioniert asynchrone Verarbeitung in React?
            </ul>
        </section>

            <section>
                <h3>Server-Calls</h3>
                <ul>
                    <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
                    <li>Häufig in React verwendet: <b>fetch</b> API
                    <ul>
                        <li>Browser-API zum Ausführen von HTTP Requests</li>
                        <li>Kein JS Standard, aber <a href="http://caniuse.com/#search=fetch" target="_blank">hohe Verbreitung</a></li>
                        <li>Spezifikation: <a href="https://fetch.spec.whatwg.org/" target="_blank">https://fetch.spec.whatwg.org/</a></li>
                        <li>Polyfill: <a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch</a></li>
                    </ul>
                </ul>
            </section>
        <section>
            <h3>Beispiel: fetch</h3>

                <pre><code class="javascript" contenteditable data-trim>
// GET
fetch('http://localhost:7000/api/greetings')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));

// PUT
fetch(url, {
    method: 'PUT',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
})
  .then(...)
</code></pre>
            </section>


        <section data-state="exkurs">
            <h2>ES6: Promises</h2>
        </section>
                <section data-state="exkurs">
                        <h3>Beispiel: fetch</h3>
<pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;

return fetch(url)
    .then(response => response.json())
    .then(json => /* ... */)
    .catch(ex => console.error('request failed', ex));
</code></pre>
                </section>
                    <section data-state="exkurs">
                        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
                        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
                    </section>

                <section data-state="exkurs">
                        <h3>Erzeugen und asynchron reagieren</h3>
   <pre class="fragment"><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>promise.then(value => console.log(value));
// Output after 1 second: Result from promise
</code></pre>
                    </section>
                    <section data-state="exkurs">
                        <h3>Verkettete Ausführung</h3>
   <pre><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
                    </section>
            <section data-state="exkurs">
                <h3>Fehler führen zum Abbruch der Chain</h3>
                <h4 class="fragment">Allerdings muss man etwas tun, um das mitzubekommen</h4>
            </section>

                    <section data-state="exkurs">
                        <h3>Catch-Klausel im Erfolgsfall</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
                    </section>
                    <section data-state="exkurs">
                        <h3>Catch-Klausel im Fehlerfall</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
                    </section>

        <section>
            <h3>fetch im Detail</h3>

            <pre><code class="javascript" contenteditable data-trim>
// 1. fetch returns a promise, that will be resolved
// with a Response object when response is received
// from server
fetch('http://localhost:7000/api/greetings')

// 2. the Response object contains a json() function,
// that returns the parsed JSON from the Response body
  .then(response => response.json())

// 3. with the resolved JSON object we set the
// component state (=&gt; leads to re-rendering)
  .then(json => this.setState({greetings: json})

// 4. in case something goes wrong (during request,
// request processing or rendering)
  .catch(ex => console.error('request failed', ex));
// as an alternative we could set and render an error msg:
//  .catch(ex => this.setState({error: ex})
</code></pre>
        </section>
        <section>
            <h3>Initiales Laden von Daten</h3>
            <ul>
                <li class="fragment">Komponenten können Lifecycle-Methoden haben: <a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank">
                        https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle
                </a> (nur Klassen!)</li>
                <li class="fragment"><code>componentDidMount</code> wird aufgerufen, wenn Komponente ins DOM gerendert wurde</li>
                <li class="fragment">Hier werden Daten üblicherweise initial geladen:<pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) {
    // intial state (empty now)
    this.state = { greetings: [] };
  }
  componentDidMount() {
    fetch('/api/greetings')
      .then(response =&gt; response.json())
      .then(json =&gt; this.setState({greetings: json})
      .catch(. . .)
    ;
  }
}
                </code></pre>
            </ul>
        </section>
        <section>
            <h3>Speichern von Daten</h3>
                <p>Zum Beispiel als Folge einer Benutzerinteraktion:</p>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  render() {
    ...
      &lt;GreetingDetail onAdd={greeting => this.saveGreeting(greeting)} />
    ...
  }
  saveGreeting(greetingToBeSaved) {
    fetch('/api/greetings', {
      method: 'POST',
      headers: ...,
      body: JSON.stringify(greetingToBeSaved)
    })
      .then(response =&gt; response.json())
      .then(json =&gt; ...)
      .catch(. . .);
  }
}
                </code></pre>
        </section>

            <section>
                <h2>Übung: Laden und Speichern der Daten von/auf einem Server</h2>
                <ul>
                <li>Entwickle eine Version vom GreetingController, die die Daten auf dem Server laden und dort wieder speichern kann</li>
                <li>Der Server ist bereits vorgegeben und kann mit <code>npm start</code> im Root-Verzeichnis gestartet werden. Er ist dann unter Port 7000 erreichbar</li>
                </ul>
            </section>
        <section>
            <h2>Vorbereitung für die Übung</h2>
            <ol>
                <li>Kopiere <code>code/material/3-remote/backend.js</code> und <code>code/material/3-remote/main.js</code> in deinen Workspace</li>
                <li>Du kannst außerdem <code>code/material/3-remote/_GreetingController.js</code> als Template verwenden. Die notwendigen
                Schritte sind dort als Kommentar markiert.</li>

            </ol>
        </section>
                <section>
                    <h2>Stelle den GreetingController um</h2>
                    <ol>
                        <li>Importiere <code>loadFromServer</code> und <code>saveToServer</code> aus dem <code>backend</code>-Modul
                        <li>Füge in der Komponente <code>GreetingController</code> zwei Methoden zum Laden und Speichern der Greetings hinzu
                        <li>Nach dem Mounten der Komponente in den DOM sollen die Greetings geladen werden (Lifecycle-Methode <code>componentDidMount</code>)
                        <li>Das <code>onAdd</code>-Callback von <code>GreetingDetail</code> soll die übergebene Greeting speichern und im Erfolgsfall
                        das gespeicherte Greeting in die Liste aller Greetings zufügen.
                    </ol>
                <br>Weitere Details findest du unter:
                    <a href="code/material/3-remote/AUFGABEN.md" target="_blank">
                        code/material/3-remote/AUFGABEN.md</a>
            </section>
        <section id="t4">
            <h1>Teil IV</h1>
            <h2>Testen (Überblick)</h2>
            <ul style="font-size:85%">
                <li><a href="code/schritte/4-test/public/index.html" target="_blank">Ziel-Anwendung</a>
                <li><a href="code/schritte/4-test/test-report.html">Test Report</a>
                <li><a href="code/schritte/4-test/coverage/lcov-report/index.html">Coverage Report</a>
            </ul>
        </section>

        <section data-transition="slide none">
            <h2>Was testen wir überhaupt?</h2>
            <ul>
                <li class="fragment"><b>UI-unabhängige Logik</b> (z.B. Services, Backend-Calls)</li>
                <li class="fragment"><b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)</li>
                <li class="fragment"><b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)</li>
                <li class="fragment"><b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit history, Titelzeile, Scrollbars etc)</li>
            </ul>
        </section>

        <section data-transition="none">
            <h2>Was testen wir überhaupt?</h2>
            <ul>
                <li style="color: lightgrey"><b>UI-unabhängige Logik</b></li>
                <li><b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt) <b>React-spezifisch!</b></li>
                <li><b>Interaktionen</b> (funktionieren meine Event-Listener korrekt) <b>React-spezifisch!</b></li>
                <li style="color: lightgrey"><b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit history, Titelzeile, Scrollbars etc)</li>
            </ul>
        </section>

        <section>
            <h2>Anforderungen</h2>
            <ul>
                <li class="fragment">Komponenten müssen im Test gerendert werden können</li>
                <li class="fragment">Gerenderte Komponenten/HTML-Elemente müssen gefunden und validiert werden</li>
                <li class="fragment">Zustand und Properties der Komponenten müssen veränderbar sein</li>
                <li class="fragment">Events müssen getriggert oder simuliert werden können</li>
                <li class="fragment">Interaktion mit DOM muss evtl möglich sein</li>
            </ul>
        </section>

        <section>
            <h1>Jest</h1>
            <p><em>"Painless JavaScript Testing" (<a href="http://facebook.github.io/jest/" target="_blank">http://facebook.github.io/jest/</a>)</em></p>
            <p class="fragment">Vollständige Test-Lösung, wird von Facebook für Testen von React verwendet:</p>
            <ul class="fragment">
                <li class="fragment">Test Runner</li>
                <li class="fragment">Specs, Assertions, Mocks</li>
                <li class="fragment">Code Coverage</li>
                <li class="fragment">Snapshot testing</li>
            </ul>
        </section>
        <section>
            <h3>Beispiel: Ein einfacher Test</h3>
            <pre><code class="javascript" contenteditable data-trim>// sum.js
export const sum = (a,b) => a+b;
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
    expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
    expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
            <h3>React Test Renderer</h3>
            <p><a href="https://www.npmjs.com/package/react-test-renderer">https://www.npmjs.com/package/react-test-renderer</a></p>
            <p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
const component = renderer.create(
        &lt;GreetingMaster greetings={someGreetings} />
);

console.log(component.toJSON());
            </code></pre>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
{ type: 'div',
  props: {},
  children:  [
    { type: 'table', props: {}, children: [Object] },
    { type: 'button', props: [Object], children: [Object] }
  ]
}
            </code></pre>

        </section>
        <section>
            <h3>"Snapshot Testing" mit Jest</h3>
            <p><code>expect(obj).toMatchSnapshot()</code> vergleicht ein JSON-Objekt mit einer gespeicherten Datei:</p>
            <ul>
                <li class="fragment">Bei <b>erster</b> Ausführung: legt Snapshot-File an
                    (<a href="images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
                    <ul>
                        <li class="fragment">Snapshotdateien werden in Git versioniert</li>
                    </ul>
                </li>
                <li class="fragment">Bei <b>folgenden</b> Ausführungen: erzeugt neuen Snapshot und vergleicht mit
                    gespeichtertem Snapshot
                </li>
                <li class="fragment">Wenn Snapshots unterschiedlich
                    <ul>
                        <li>Fehler samt Diff (<a href="images/jest-snapshot-diff.png" target="_blank">Beispiel</a>)</li>
                        <li>Im Watch Mode kann Snapshot aktualisiert werden
                            <img src="images/jest-snapshot-update.png"></li>
                    </ul>
                </li>

            </ul>
        </section>

        <section>
            <h3>Snapshot Testing mit Jest und React</h3>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';

test('it should render correctly', () => {

  const someGreetings = [ . . . ];

  const component = renderer.create(
    &lt;GreetingMaster greetings={someGreetings} />
  );

  expect(component.toJSON()).toMatchSnapshot();
});
            </code></pre>
            <p class="fragment"><em>Snapshot sagt nicht, ob UI richtig oder falsch gerendert wird, sondern nur, ob sie verändert wurde!</em></p>
        </section>

        <section>
            <h3>Enzyme</h3>
            <p><em>JavaScript Testing utilities for React (<a href="http://airbnb.io/enzyme/" target="_blank">http://airbnb.io/enzyme/</a>)</em></p>
            <p>Bibliothek mit Funktionen zum Testen von React Komponenten</p>
            <ul>
                <li class="fragment">Rendern von Komponenten:
                    <ul>
                        <li><b>shallow</b> zum "flachen" Rendern einer Komponente</li>
                        <li><b>mount</b> zum Rendern einer Komponete in einen (headless) DOM, z.B. jsdom</li>
                    </ul>
                </li>
                <li class="fragment">Navigieren durch den DOM und Suchen von Elementen und Komponenten</li>
                <li class="fragment">Modifizieren von Komponenten und Auslösen von Events</li>
            </ul>
        </section>

        <section>
            <h3>Testen einer Komponente mit Jest und Enzyme</h3>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>import {mount} from 'enzyme';
import GreetingController from '...';
import GreetingDetail from '...';
test('it should open detail view on button click', () => {
    // mount the component into a real dom (implemented by JSDom)
    const component = mount(&lt;GreetingController  />);

    // on initial render the list with greetings (GreetingMaster)
    // is visible but no GreetingDetail
    expect(component.find(GreetingDetail)).toHaveLength(0);

    // find the "add" Button...
    const addButton = component.find('button');

    // click on the button
    addButton.simulate('click');

    // now the GreetingDetail should be visible
    expect(component.find(GreetingDetail)).toHaveLength(1);
});
            </code></pre>
        </section>

        <section id="t5">
            <h1>Teil V</h1>
            <h2>Integration mit 3rd-Party Bibliotheken</h2>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>3rd Party Libs?</h2>
            <div class="fragment">
                <p>Es gibt eine große Anzahl von sehr praktischen JavaScript-Bibliotheken</p>
                <p>Viele davon sind aber nicht als React-Komponenten entwickelt worden</p>
            </div>
            <div class="fragment">
                <p>Beispiels</p>
                <p><em>jQuery</em> und <em>jQuery</em> Plugins wie z.B. <em>Bootstrap</em></p>
                <p><em>d3</em> für interaktive SVGs und Chart Bibliotheken wie <em>nvd3</em></p>
            </div>
        </section>

        <section>
            <h3>Unser Beispiel: Verteilung der Grüße</h3>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">
                <img src="images/screenshot-nvd3.png" height="400px">
            </a>
            <p><em>nvd3</em> Pie Chart mit <em>d3</em></p>
        </section>

        <section>
            <h3>Aufgabe: Einbetten des Pie Charts in eine React-Komponente</h3>
        </section>

        <section>
            <h3>Herausforderungen?</h3>
            <ol>
                <li>Wie kommen wir an den DOM Knoten der React-Komponente?
                <li>Wie sagen wir React, dass nun NVD3 den Rest macht? Also, dass React nicht mehr neu rendern soll.
                <li>Änderungen des Zustands sollen nach wie vor richtig dargestellt werden
                <li>Ab welchem Zeitpunkt soll NVD3 das Rendern übernehmen?
                <li>Wie können wir aus NVD3 heraus auch wieder andere React-Komponenten beeinflussen?
                <li>Wie räumen wir wieder auf?
            </ol>
        </section>
        <section>
            <h3>Hintergrund: Charts mit NVD3</h3>
            <p>Basiert auf D3.js</p>
            <p>Benötigt svg DOM-Element um sich zu rendern</p>
            <p class="fragment">Stark vereinfachtes Beispiel:</p>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>import d3 from 'd3';
import nv from 'nvd3';

// Chart erzeugen
const chart = nv.models.pieChart();
// ...Chart Config ausgelassen ...

// mit d3 rendern und mit Daten versorgen
const element = document.getElementById('chart');
d3.select(element);
  .datum(data)
  .call(chart);

// Callbacks registrieren (z.B. bei Klick auf ein Element)
chart.pie.dispatch.on("elementClick",
                       e => console.log(e.data.label));
            </code></pre>

        </section>
        <section>
            <h3>React Chart Komponent #2</h3>
            <p>React Callback Funktionen</p>
            <ul>
                <li>(einmalig) <code>componentDidMount()</code>: Komponente wurde gerendert, Element sind im DOM</li>
                <li><code>componentWillReceiveProps(nextProps)</code>: An die Komponente wurden neue Properties übergeben. Die neuen Properties
                    werden als Parameter übergeben</li>
                <li><code>shouldComponentUpdate()</code>: Entscheidet, ob Komponete erneut gerendert werden soll (default: <code>true</code>)</li>
                <li>(einmalig) <code>componentWillUnmount()</code>: Wird aufgerufen, bevor Komponente aus dem DOM entfernt wird</li>
            </ul>

        </section>

        <section>
            <h3>React Chart Komponente #1</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    render() {
        // (1) we render an empty svg and
        //     remember the reference to the DOM node
        return &lt;svg ref={c => this._chart = c}>&lt;/svg>
    }

    componentDidMount() {
        const {data, onSegmentSelected} = this.props;

        // (2) once rendered by react we create the nvd3 chart
        const chart = createNvd3Chart(this._chart, data);

        // (3) we delegate the label of clicked segment
        //     back to parent component
        if (onSegmentSelected) {
            chart.pie.dispatch.on(
                "elementClick", e => onSegmentSelected(e.data.label));
        }
    }

    // ...
}
       </code></pre>
        </section>

            <section>
            <h3>React Chart Komponent #2</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    // ...

    componentWillReceiveProps(nextProps) {
        const {data} = nextProps;
        // (4) we get updates of properties making it reactive
        updateNvd3Chart(this._chart, data);
    }

    shouldComponentUpdate() {
        // (5) once rendered we will never render again
        // (svg-Element is managed by D3)
        return false;
    }

    // (6) called just before destroying component
    componentWillUnmount() {
        this._d3selection.remove();
    }
}
       </code></pre>
        </section>

        <section>
            <section>
                <h2>Übung: Ein Pie-Chart integrieren</h2>
                <h3>Das Pie Chart soll eine Übersicht aller Grüße anzeigen</h3>
                <h3>Ein Klick auf ein Segment des Pie Charts soll die Liste der Grüße filtern</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/5-third-party</code> in deinen src-Ordner
                    <li>binde die Chart-Komponente in die render-Methode des <code>GreetingController</code> ein
                    <li>alle Stellen die du ändern musst sind dort bereits mit einem Kommentar versehen
                </ul>
                <p>Zusatzaufgabe: Ein zweites Mal klicken auf das Segment soll den Filter wieder löschen</p>
            </section>
        </section>

        <section id="t6">
            <h1>Teil VI (Überblick)</h1>
            <h2>Client-seitiges Routing</h2>
            <a href="code/schritte/router-v4/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>
        <section>
            <h2>Warum Routing?</h2>
            <span class="fragment">
                <p>Mappen von URLs auf Komponenten
                    <br><span style="font-size: 80%">(Navigation findet ohne Server-Roundtrip statt)</span></p>
            </span>
            <span class="fragment">
            <p>Komponenten halten (Teil) des Zustandes der Anwendung
                <br><span style="font-size: 80%">Welche Komponente ist sichtbar (Master oder Detail)?</span>
                <br><span style="font-size: 80%">Welche Daten werden dafür geladen (z.B. Greeting Id)</span></p>
                            </span>
        </section>

        <section>
            <h2>Herausforderungen</h2>
            <p class="fragment">Auf Änderungen der URL reagieren
            <br><span style="font-size: 80%">Ableiten des Zustandes aus der URL
                    <br>Wenn sich die URL ändert, kein Server roundtrip</span></p>
            <p class="fragment">Hierarchische Komponentenstrukturen</p>
            <p class="fragment">Beim Klick auf Links etc aktualisieren der URL</p>
        </section>

        <section>
            <h2>React Router</h2>
            <ul>
                <li>Kein Bestandteil von React</li>
                <li>Sehr häufig verwendet (de-facto Standard)</li>
                <li>Aktuelle Version 4: <a href="https://reacttraining.com/react-router/" target="_blank">
                    https://reacttraining.com/react-router/</a></li>
            </ul>
        </section>
        <section>
            <h3>Router</h3>
            <p class="fragment">Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss</p>
            <p class="fragment">Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:
                <ul>
                    <li class="fragment"><b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
                    <li class="fragment"><b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
                </ul>
            </p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router} from "react-router-dom";

const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
        </section>

        <section>
            <h3>Route</h3>
            <ul>
            <li class="fragment">Kann überall in der Anwendung verwendet werden, wo Pfad-abhängig Komponenten ausgewählt werden sollen</li>
            <li class="fragment">Mit <code>path</code> wird der Pfad übergeben, für den die Route matchen soll</li>
            <li class="fragment">Mit <code>component</code> wird die Komponente übergeben</li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route} from "react-router-dom";

const app = &lt;Router>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
        </section>
        <section>
            <h3>Route</h3>
            <ul>
                <li class="fragment">Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert</li>
                <li class="fragment">Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
                <li class="fragment">Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung) </li>
                <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/"
  render={() => {
    return loggedIn ? &lt;GreetingMaster greetings={initialGreetings} />
                    :
                    &lt;LoginForm />
                    }
/>
            </code></pre>
            </ul>
        </section>
        <section>
            <h3>Pfade</h3>
            <ul>

                <li class="fragment">Sind per Default gültig für Teilstrings</li>
                <li class="fragment">Mit <code>exact</code> kann das Verhalten verändert werden
                    <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// trifft zu für / und /greeting
&lt;Route path="/" component={GreetingController}/>
// trifft nur zu für /
&lt;Route path="/" exact component={GreetingController}/>
            </code></pre>
                </li>
                <li class="fragment">Route ohne <code>path</code> matcht immer</li>
                <li class="fragment">Kann variable Segmente enthalten:
                    <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/greeting/:greetingId"
          component={&lt;GreetingDisplay />} />

// in GreetingDisplay kann die greetingId über
// this.props.match.params.greetingId abgefragt werden
            </code></pre>

                </li>
            </ul>
        </section>
        <section>
            <h3>Switch</h3>
            <ul>
                <li class="fragment">Wenn mehrere path-Ausdrücke matchen, werden mehrere Komponenten gerendert (z.B. "/" und "/greetings")</li>
                <li class="fragment"><code>Switch</code> sorgt dafür, dass nur die erste Komponente im Block gerendert wird</li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route, Switch} from "react-router-dom";

const app = &lt;Router>
  &lt;Switch>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>

    // "No match": ohne Pfad
    &lt;Route component={NotFoundPage}/>

  &lt;/Switch>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
            </code></pre>
        </section>

        <section>
            <h3>Router Properties für Komponente</h3>
            <p>Der Router übergibt drei Properties an die gerenderte Komponente (oder an die <code>render()</code>-Funktion)</p>
            <ul>
                <li class="fragment"><code>match</code>: Enthält u.a. die Parameter aus dem Pfad (<code>match.params.xyz</code>)</li>
                <li class="fragment"><code>history</code>: Zum Arbeiten mit der History (z.B. <code>push()</code> zum Navigieren)</li>
                <li class="fragment"><code>location</code>: Der aktuelle Pfad (z.B. <code>pathname</code>, <code>search</code>)</li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
const HelloComponent = ({match, history, location}) => (
  &lt;div>
    &lt;h1>Hello, {match.params.name}&lt;/h1>
    &lt;small>The current path is: {location.pathname}&lt;/small>
    &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
  &lt;/div>
);

// ...
&lt;Route path="/greet/:name" component={HelloComponent}/>

            </code></pre>
        </section>

        <section>
            <h3>Links</h3>
            <p>Mit <code>Link</code> und <code>NavLink</code> können Links erzeugt werden</p>
            <ul>
                <li>Mit <code>to</code> wird das Ziel angegeben</li>
                <li>Gerendert wird per default ein <code>a</code> Element</li>
                <li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
                <li>Mit <code>activeClassName</code> und <code>activeStyle</code> auf <code>NavLink</code> können
Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {Link, NavLink} from "react-router-dom";
&lt;Link to='/greetings'>Show all greetings&lt;/Link>
&lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>

            </code></pre>
        </section>

        <section>
            <h2>Geschafft ;-)</h2>
            <h3>Vielen Dank für Eure Teilnahme!</h3>
            <p>Kontakt: nils@nilshartmann.net</p>
        </section>


    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>

<script>
    Reveal.addEventListener( 'ready', function( event ) {
        if (window.location.hostname.indexOf('localhost') !== -1) {
            // only applies to presentation version
            Reveal.configure({ controls: false });
        } else {
            // only applies to public version
            $('.fragment').removeClass('fragment');
        }
        // applies to all versions
        $('code').addClass('line-numbers');
    } );
</script>


<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
