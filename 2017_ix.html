<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>React Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
        .reveal pre code {
            max-height: 1000px !important;
        }

        .reveal section img {
          border:0;
          box-shadow:0 0 0 0
        }

        html.exkurs body {
          background: rgb(252, 220, 185) url("ai/es6-icon.png") no-repeat right bottom;
        }

    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!--
Titel:

Einführung in die Philosophie von React

Abstract:

Dieser Workshop führt dich in die Programmierung und Philosophie von
React ein. Dabei wirst du sehen, wie React mit vielen bisher
bestehenden Best-Practices bricht und warum das so ist. Wir werden uns
daher viel Zeit für individuelle Fragestellungen und Übungen nehmen,
um dir diese Grundlagen auch nachhaltig zu vermitteln.

Am Ende es Workshops hast du eine Vorstellung davon, wie
React-Anwendungen aufgebaut sind und wie du eine neue React-Anwendung
beginnst. Du kannst ebenso einschätzen, was die Stärken und Schwächen
von React sind.

Inhaltlich wirst du lernen, React-Komponenten zu entwickeln und daraus
eine ganze Anwendung zu bauen. Dazu sehen wir uns einen typischen
Entwicklungsprozess mit Webpack und Babel an. Außerdem zeigen wir dir, wie du
Datenzugriffe auf einen Server machen und 3rd-Party-Bibliotheken in deine
Anwendung integrieren kannst. Zur Strukturierung deiner Anwendung
und der Trennung von UI und Geschäftlogik sehen wir uns das Framework "Redux"
 an, das häufig gemeinsam mit React
 eingesetzt wird.

Mit einem Ausblick auf das React-Ökosystem schließen wir den Workshop ab,
so dass du Orientierung und Ideen für weitere Themen bekommst.

Zielgruppe

Du hast bereits grundlegende Erfahrungen mit JavaScript, am besten mit
der Version ES2015. Solltest du ES2015 noch nicht kennen, keine Angst,
wir beginnen den Workshop mit einer Einführung/Wiederholung der
Sprach-Features, die du für die React-Programmierung auch wirklich
brauchst. Wir setzen keine Erfahrung mit React voraus und beginnen
tatsächlich bei Null.

Technische Voraussetzungen der Teilnehmer

Du brauchst ein Laptop, auf dem du Software installieren kannst und
das den Anforderungen moderner Software-Entwicklung gewachsen ist.
Bitte installiere vor dem Workshop Node.js (https://nodejs.org), git
(https://git-scm.com/downloads) und eine IDE. Wir empfehlen entweder
Visual Studio Code (kostenlos, https://code.visualstudio.com/), oder Webstorm
(https://www.jetbrains.com/webstorm/specials/webstorm/webstorm.html)
bzw. IDEA (https://www.jetbrains.com/idea/). Als Browser empfehlen wir
Chrome, es tut aber auch Firefox, Safari oder der aktuelle
Edge-Browser von Microsoft.


Mögliche Agenda (grob, ohne Pausen):

- Teil 1 (3 Stunden)
  - Einführung in React
  - Build-Prozess
  - ES6-Grundlagen
  - React Komponenten
  - Komponentenhierarchien

- Teil 2 (2 Stunden) Serverzugriffe
 - Die fetch-Bibliothek
 - ES6 Promises
 - Lebenszyklus von React Komponenten

- Teil 3 (2 Stunden) Integration mit 3rd-Party-Apps
 - Referenzen in React
 - Zugriff von React auf 3rd-Party Lib
 - Zugriff von Lib auf React-Komponente


- Teil 4 (3 Stunden): Redux
 - Motivation: Trennung von UI und Logik, nachvollziehbarerer Datenfluss etc
 - (Einführung Flux?)
 - Einführung Redux / Redux im Überblick
 - Action, Action Creator, Reducer
 - Verbinden von Komponenten
 - Store (mehrere Reducer)
 - Middleware / Asynchrone Aufrufe mit thunk

- Teil 5 (1 Stunde): Performance Optimierung
 - Immutable / shouldComponentUpdate (Immutable ggf schon vorher)
 - Prod-Build

- Teil 6 (1 Stunde)
 - Ausblick / Überblick über weiteres React Öko-System

Zeitplan:
Tag 1:

ab 10 Uhr Registrierung
11 Uhr Beginn Workshop
12.30 - 13.30 Uhr Mittagessen
13 - 14 Uhr Mittagessen
15.30  - 15.45 Uhr: 1. Kaffeepause
17.15 - 17.30 Uhr: 2 Kaffeepause
Ende gegen 18.30 Uhr

Tag 2:

9 Uhr Beginn
10.45 - 11.00 Uhr: Kaffeepause
12.30 - 13.30 Uhr: Mittagessen
15.00 - 15.15 Uhr: Kaffeepause
Ende gegen 16.30 Uhr



  -->

<!--
    TODO:
    - Optionaler Schritt: GraphQL als optionaler Server-Teil
    - Async Await Demo, 3b-remote-async-await
    - Was kommt in 16? https://twitter.com/reactjs/status/866329614796431360?s=03
-->

    <!--http://dpunkt.de/lecture.php?event_id=3536-->

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h3>React Workshop - Vorbereitung</h3>
        <p>Falls noch nicht gemacht:</p>
        <ol style="font-size: 85%">
          <li><code>git clone https://github.com/DJCordhose/react-workshop.git</code></li>
          <li>Im geklonten Verzeichnis: <code>npm install</code>
            <br><span  style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
          <li><code>npm start</code></li>
          <li>In neuem Terminal: in <code>code/workspace</code> wechseln</li>
          <li>Ausführen: <code>npm start</code></li>
          <li>Browser öffnen: <a href="http://localhost:8080" target="_blank">http://localhost:8080</a></li>
          <li>Wenn dort ein Hello-World-Text erscheint ist alles gut
        </ol>
        <p>Folien: Im geklonten Verzeichnis <code>2017_ix.html</code>
        </p>
      </section>
      <section>
        <h1>React Workshop</h1>
        <div style="float:left">

          <p>
            <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>

          </p>
          <p>
            <a href="http://zeigermann.eu" target="_blank">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose" target="_blank">@DJCordhose</a>
          </p>
          <p><a href="http://bit.ly/react-ix">http://bit.ly/react-ix</a></p>
          <p style="border-top: 2px solid darkgray;margin-top:25px;padding-top:25px;">
            <a href="https://reactbuch.de" target="_blank">React Buch (https://reactbuch.de)</a></p>
          </p>
        </div>
        <div style="float:right">
          <img style="max-height:350px" src="images/reactbuch-de.png" />
          <p>

        </div>
      </section>

      <section>
            <h2>Inhalt</h2>
            <ul>
                <li><a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
                <li><a href="#/t1">Teil I: React-Komponenten und ES6 Grundlagen</a>
                <li><a href="#/t2">Teil II: Komponentenhierarchien</a>
                <li><a href="#/t3">Teil III: Remote-Calls gegen Server</a>
                <li><a href="#/t4">Teil IV: Integration mit 3rd-Party Libs</a>
                <li><a href="#/t5">Teil V: Zustandsmanagement (Redux)</a>
                <li><a href="#/t6">Teil VI: Performance</a>
            </li>
            </ul>
        </section>


        <section id="example-app">
            <h2>Beispiel-Anwendung</h2>
            <a target="_blank" href="code/schritte/redux/7-redux-complete-app/public/index.html"><img src="images/greeting-app.png" style="border:0;box-shadow:0 0 0 0;max-width: 80%"/></a>
        </section>

        <section id="t0">
            <h1>Teil 0</h1>
            <h2>React-Einführung und Build-Prozess</h2>
        </section>

        <section id="react">
            <h2>React</h2>
            <ul>
                <li class="fragment">Framework für Facebook und viele andere
                <li class="fragment">Komponenten kapseln Template und Logik
                  <li class="fragment">Deklarativ
                <li class="fragment">Abstraktion vom DOM: <em>f(model) -> UI</em>
                <li class="fragment">Minimales API
                <li class="fragment">Ein-Weg-Data-Binding: Zustandsänderungen stellen Komponente <b>komplett</b> neu dar
                <li class="fragment">Kann im Browser und auf dem Server rendern
                <li class="fragment">wird für komplette Anwendung typischerweise mit React Router und einem Flux-Framework gekoppelt
                <li class="fragment">viel Inspiration aus der funktionalen Ecke (Immutable, pure functions, stateless)
            </ul>
        </section>

        <section>
            <h3>React Komponenten</h3>
            <ul>
                <li class="fragment">Werden als ES6 Klasse oder Funktion implementiert
                <li class="fragment">Keine Templatesprache (stattdessen JavaScript)
                <li class="fragment">Templates können HTML-artige Syntax enthalten (JSX)
            </ul>
            <pre class="fragment"><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return &lt;h1 className='title'>Hello, World!&lt;/h1>
  }
}
</code></pre>
        </section>

      <section>
        <h3>Eine erste Komponente: Hello, World!</h3>
        <a target="_blank" href="code/schritte/0-hello_world/public/index.html">Demo</a>
      </section>

      <section data-state="exkurs">
        <h2>ES6-Referenz</h2>
        <p>ES6 Features werden vorgestellt, wo wir sie brauchen</p>
        <p><a href="http://exploringjs.com/es6/" target="_blank">
          http://exploringjs.com/es6/</a>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Template Strings</h3>
        <p>Template Strings werden in Backticks (``) geschrieben und können Ausdrücke
          (in <code>${}</code>) enthalten:</p>

        <pre class="fragment"><code class="javascript" contenteditable>const name = "Susi";
const greeting = `Hello, ${name}`; // Hello, Susi

const four = `Two and two is: ${2+2}` // Two and two is: 4

const time = `The time is: ${new Date()}`); // The time is: ...
            </code></pre>
      </section>


      <section data-state="exkurs">
        <h3>ES6: Klassen</h3>
        <pre><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return `${this.name} codes in ${this.language}`;
    }
}</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
      </section>

      <section data-state="exkurs">
        <h3>ES6: Arrow Functions</h3>
        <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// Klammern können weggelassen werden, genau ein Parameter
// ebenso die geschweiften Klassen, wenn nur ein Statement:
const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
      </section>


                <section>
                    <h3>Hello World React</h3>
<pre><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return (&lt;div>
            &lt;input onChange={event => this.updateModel(event)}
                   value={this.state.greeting} />
            &lt;p>{this.state.greeting}, World&lt;/p>
            &lt;button
                onClick={() => this.reset()}>
                Clear
            &lt;/button>
        &lt;/div>);
  }</code></pre>
<pre class="fragment"><code contenteditable class="javascript">  constructor(props) {
    super(props);
    this.state = {greeting: this.props.greeting};
  }
  updateModel(event) {
    this.setState({greeting: event.target.value});
  }
  reset() {
    this.setState({greeting: ""});
  }
}</code></pre>
                </section>

        <section>
                    <h3>Aufruf</h3>
<pre><code data-trim contenteditable>
// index.html
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
<pre class="fragment"><code data-trim contenteditable class="javascript">
// main.js
import React from 'react';
import ReactDOM from 'react-dom';

import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage greeting="Hello"/>, mountNode);
</code></pre>
                    <a target="_blank" href="code/hello_world/public/index.html">Run</a>
                </section>


    <section>
        <h2>Buildprozess</h2>
        <ul>
            <li>ES6- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <li>Typische Werkzeuge
                <ul><li>Babel (Compiler)
                    <li>Webpack (Bundler)
                    <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
                    </ul>
        </ul>
    </section>
     <section>
        <h2>Webpack und Babel</h2>
        <img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0"/>
    </section>
      <section>
        <h2>Webpack Development Server</h2>
        <ul>
          <li>Zum Ausführen der Anwendung wird ein Webserver benötigt</li>
          <li class="fragment">Für die Entwicklung <b>Webpack Dev Server</b>:
            <ul>
              <li>...führt Webpack auf Basis der Projekt Webpack Konfiguration aus</li>
              <li>...erzeugt Ausgabe nur in Memory (nicht auf Platte)</li>
              <li>...Hot Reloading: Automatische Aktualisierung nach Code Änderung</li>
              <li>...React Hot Loader: Zustand bleibt nach Aktualisierung erhalten (Beta)</li>
            </ul>
          <li class="fragment"><code>npm start</code> in unserem Beispiel-Projekt</li>
        </ul>
      </section>

    <section>
      <section>
          <h2>Übung: React Hello-World</h2>
          <h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
      </section>
      <section>
        <h3>Schritt #1: Tool-Chain starten (falls noch nicht gemacht)</h3>
        <p>Nutze für die Übungen das <code>workspace</code>-Verzeichnis in diesem Repository. Hier ist eine Tool-Chain mit Webpack und Babel vorbereitet</p>
        <ol style="font-size: 85%">
          <li><code>npm install</code> (auf oberster Ebene)
            <br><span  style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
          <li><code>cd code/workspace</code>
          <li><code>npm start</code>
          <li>Öffne <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
          <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
        </ol>
      </section>
      <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <ul>
              <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel aus den Folien
              <li>Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.
                  <ul>
                      <li>Alle Eingaben sollen in Großbuchstaben auftauchen
                      <li>Gib irgendeine Rückmeldung wenn die Eingabe erfolgreich gelöscht wurde
                  </ul>
          </li>
          </ul>
      </section>
    </section>

        <section id="t1">
            <h1>Teil I</h1>
            <h2>React-Komponenten und ES6 Grundlagen</h2>
            <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>Rendering
                <li>Properties und Zustand
                <li>Refs
            </ul>
        </section>

            <section>
                <h3>React: Rendering</h3>
                <em>Jede React-Komponente braucht eine <code>render</code>-Methode:</em>
                <ul>

                    <li class="fragment">wird aufgerufen beim ersten Rendering und immer wenn sich der Zustand ändert</li>
                  <li class="fragment">kann HTML-artige <b>JSX</b>-Syntax nutzen</li>
                    <li class="fragment">JSX kann pures JavaScript in geschweiften Klammern enthalten (<code>{}</code>)
                </ul>
<pre class="fragment"><code class="jsx" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input
           onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
        </section>
      <section>
        <h3>React: JSX</h3>
        <ul>
          <li style="font-size: 80%" class="fragment">Wird wie HTML hingeschrieben, inkl Attribute: <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre></li>
          <li style="font-size: 80%"  class="fragment">Attribute, die keine Strings sind, müssen in {} eingechlossen werden:
            <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
          </li>
          <li style="font-size: 80%"  class="fragment">Kann pures JavaScript enthalten, eingeschlossen in {}:
            <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
          </li>

          <li style="font-size: 80%"  class="fragment"><code>class</code>-Attribut heißt <code>className</code>:
            <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
          </li>
          <li style="font-size: 80%"  class="fragment">CSS-Eigenschaften werden als Objekt übergeben in Camel-Case-Notation:
            <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
          </li>
        </ul>
      </section>


      <section>
                <h3>React: Rendering #2</h3>
                <ul class="fragment">
                    <li>DOM-Events werden in React-Events verpackt
                    <li>React-Events haben weitgehend selbe API wie DOM-Events
                    <li>Es gibt keine automatische Bindung an Modelle
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
               value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  updateModel(greeting) {
    this.setState({greeting});
  }
  // ...
}
</code></pre>
        </section>
      <section data-state="exkurs">
        <h3>ES6: Erweiterte Objekt-Literale</h3>
        <pre><code class="javascript" contenteditable>const name = 'Oma';
const person = {
    // ES5: name: name
    name
};
console.log(person.name); // Oma
   </code></pre>
      </section>

      <section data-state="exkurs">
            <h3>ES6: Computed Properties</h3>
          <em>Berechnete Keys in Objekten</em>
            <pre><code class="javascript" contenteditable>const schluessel = 'name';
const person = {
  [schluessel]: 'Klaus'
};
console.log(person.name); // Klaus

let id = 1;
const personen = {
  [`id_${id++}`]: 'Klaus',
  [`id_${id++}`]: 'Susi'
};
console.log(personen); // Object {id_1: "Klaus", id_2: "Susi"}
   </code></pre>
        </section>


        <section data-state="exkurs">
        <h2>ES6: Module, Importe und Exporte</h2>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Export einer einzigen Klasse</h3>
        <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
        <pre><code class="javascript" contenteditable>// Person.js
// in einer Zeile zusammengefasst
export default class Person {
  // ...
}
   </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Import</h3>
        <pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Benannte Exporte</h3>
        <pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}

export showInfo = msg => window.alert(`Wichtige Info: ${msg}`);

// or
function displayInPage(text) { . . . }
const showInfo = ...;
export { displayInPage, showInfo };
   </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
        <!--display('Hello, World');-->
        <!--</code></pre>-->
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
        <!--util.displayInPage('Hello, World');-->
        <!--</code></pre>-->
      </section>
      <!--<section>-->
      <!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
      <!--</section>-->

      <!--<section>-->
      <!--<h3>Tagged Template Literals</h3>-->
      <!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
      <!--Mini-DSLs: Template-Literals mit tag-->
      <!--</a>-->
      <!--</p>-->

      <!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
      <!--console.log(strings);-->
      <!--//[ '', ' codes in ', '.' ]-->
      <!--console.log(values);-->
      <!--//[ 'Oma', 'Haskell' ]-->
      <!--return 'whatever you want';-->
      <!--}-->
      <!--</code></pre>-->

      <!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
      <!--console.log(expanded);-->
      <!--//whatever you want-->
      <!--</code></pre>-->

      <!--</section>-->

      <section data-state="exkurs">
        <h3>ES6: Destructuring von Objekten</h3>
        <pre><code class="javascript" contenteditable>const person = {
  name: 'Olli',
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const {name, notThere} = person;
console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>function someFunction({name, notThere}) {
  console.log(`name=${name}`);
  // name=Olli
  console.log(`notThere=${notThere}`);
  // notThere=undefined
}
someFunction(person);
</code></pre>
      </section>
        <section>
            <h3>React: Properties und Zustand</h3>
            <ul class="fragment">
                <li><b>Properties</b> werden der Komponente von <b>außen</b> übergeben (und nicht verändert)</li>
                <li><b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
                <li>Beides sind Objekte mit Key-Value-Paaren</li>
                <li>Beide können an Unterkomponenten übergeben werden</li>
            </ul>
        </section>

        <section>
            <h3>Properties einer Komponente</h3>
            <ul class="fragment">
                <li>Properties werden von außen über den Konstruktor übergeben</li>
                <li>Properties dürfen nicht verändert werden</li>
                <li>Zugriff über <code>this.props</code></li>
                <li><code>this.props.children</code> enthält Kind-Elemente</li>
            </ul>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
class TitleComponent extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
      return &lt;h1>{this.props.title}&lt;/h1>
    }
   // ...
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
  &lt;TitleComponent title='Hello World' />
</code></pre>

        </section>

        <section>
            <h3>Zustand einer Komponente</h3>
            <ul class="fragment">
                <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server</li>
                <li>Werte üblicherweise immutable</li>
                <li><b>Initialisieren</b> im Konstruktor mit <code>this.state={}</code>
                <li>Zustand <b>lesen</b> über <code>this.state</code>
                <li>Zustand <b>setzen</b> über <code>this.setState()</code>
                <ul><li><b>Achtung:</b> kein "reiner" Setter</li>
                    <li>Führt alten und neuen Zustand zusammen</li>
                    <li>Wird asynchron ausgeführt!</li>
                    <li><b>Löst erneutes rendern der <i>gesamten</i> Komponente aus</b></li>
                </ul>
            </ul>
            </section>

            <section>
                <h3>Beispiel: Zustand einer Komponente</h3>
<pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input name="name"
            value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
        </section>
        <section>
            <h3>Render Zyklus</h3>
            <img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Virtual DOM</h3>
            <img src="images/virtual-dom.png" style="border:0;box-shadow:0 0 0 0">
        </section>

      <section>
        <h3>React: Referenzen auf nativen DOM</h3>
        <em>Elementen kann eine Callback-Funktion <code>ref</code> übergeben werden</em>
        <ul>
          <li class="fragment">Funktion wird nach dem Rendern mit Referenz auf DOM Element aufgerufen (oder <code>null</code>)
          <li class="fragment">Diese Referenz kann man z.B. als Member-Variable speichern
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
    render() {
        return (
            &lt;div>
                &lt;input ref={inputNode => this.inputNode = inputNode} />
                &lt;button
                    onClick={() => this.inputNode.focus()}>
                    Focus
                &lt;/button>
            &lt;/div>);
    }
}
</code></pre>
      </section>
        <section>
      <section>
          <h2>Übung: Detail-Ansicht für unsere Gruß-Anwendung</h2>
          <em>Erzeuge eine Komponenten mit der man einen Namen und eine Grußformel eingeben kann</em>
      </section>
      <section>
          <h3>Schritte</h3>
          <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
          <ul>
              <li>benenne deine Komponente in <code>GreetingDetail</code> um
              <li>du brauchst zwei Eingabefelder, die <code>name</code> und <code>greeting</code> im Zustand der Komponente setzen
              <li>Kannst du die Komponente so bauen, dass du mit einer einzigen update-Methode beide Felder im Zustand updaten kannst?
              <li>Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand initialisieren
          </ul>
      </section>
    </section>

        <section id="t2">
            <h1>Teil II</h1>
            <h2>Komponentenhierarchien</h2>
            <em>Komplette Anwendung aus Komponenten bauen</em>
            <p><a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a></p>
        </section>

        <section>
            <h2>Thinking in React</h2>
            <p><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank">
                https://facebook.github.io/react/docs/thinking-in-react.html
            </a>
            </p>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li class="fragment">Komponenten als Funktion
                <li class="fragment">Darstellung von Listen und Keys
                <li class="fragment">Architektur-Idee: Controller-Komponente und View-Komponente
                <li class="fragment">Durchreichen von Zustand und Callbacks
                <li class="fragment">PropTypes
            </ul>
        </section>

            <section>
                <h3>Komponenten als Funktion</h3>
              <em>Komponenten können auch als reguläre JavaScript Funktion geschrieben werden</em>
                <ul>
                    <li class="fragment">entspricht der <code>render</code>-Methode</li>
                    <li class="fragment">Properties werden per Parameter in einem Objekt übergeben</li>
                    <li class="fragment">Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
                    <li class="fragment">Empfehlung: Funktionen statt Klassen verwenden (wenn möglich)</li>
                </ul>
              </section>
      <section data-transition="none">
        <h3>Komponenten als Funktion</h3><pre class="fragment"><code class="javascript" contenteditable data-trim>
import React from 'react';

function Greet(props) {
  return (
      &lt;div>
          &lt;h1>{props.greeting}&lt;/h1>
        &lt;h2>{props.name}&lt;/h2>
      &lt;/div>
  );
}

// Verwendung:
&lt;Greet name="Susi" greeting="Hello" /&gt;

</code></pre></section>
                <section data-transition="none">
                    <h3>Komponenten als Funktion</h3>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Mit Destructuring
function Greet({greeting, name}) {
  return (
      <div>
          <h1>{greeting}</h1>
          <h2>{name}</h2>
      </div>
  );
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Als Arrow Function
const Greet = ({greeting, name}) => <div>
    <h1>{greeting}</h1>
    <h2>{name}</h2>
  </div>
}
</code></pre>

        </section>

            <section>
                <h3>Listen und Keys</h3>
                <ul class="fragment">
                    <li>JSX bietet nichts für Listen
                    <li>Ausgabe typischerweise über <code>Array.map</code>
                    <li>Elemente einer Liste brauchen einen eindeutigen key
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [{
    id: 0,
    name: 'Olli',
    greeting: 'Huhu'
},
{
    id: 1,
    name: 'Oma',
    greeting: 'Hallo'
}
];
const body = greetings.map(greeting =>
    &lt;tr key={greeting.id}>
        &lt;td>{greeting.name}</td>
        &lt;td>{greeting.greeting}</td>
    &lt;/tr>);
</code></pre>
        </section>

      <section>
        <h3>Komponenten in Hierarchien</h3>
        <p>Beispiel: Unsere Anwendung</p>
        <img src="ai/greeting-hierarchy-without-callbacks.png"/>
      </section>

      <section>
            <h3>Controller und Child-Views</h3>
            <!--<img src="smart-dumb.jpg">-->
            <!--<img src="smart-dumb.png">-->
            <img src="images/smart-dumb-w-label.png">
        </section>

        <section>
            <h3>Durchreichen vom Zustand und Callbacks</h3>
            <ul class="fragment">
                <li>Funktioniert beides über Properties
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        const {greetings} = this.state;
        return (
            <div>
                &lt;GreetingMaster greetings={greetings}
                    onAdd={() => this.setState({mode: MODE_DETAIL})}
            </div>);
    }
    // ...
}
    </code></pre>
    </section>
    <section>
        <h3>Properties übergeben mit Object-Spread</h3>
        <ul class="fragment">
                <li>Übergibt <b>alle</b> Eigenschaften eines Objektes als individuelle Properties</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {

    const greeting = { name: 'Klaus', greeting: 'Hello' };

    render() {
        return &lt;GreetingDetail {...greeting} />

        // entspricht:
        // &lt;GreetingDetail name='Klaus' greeting='Hello' />
    }
}
        </code></pre>
    </section>

      <section>
        <h3>PropTypes</h3>
        <em>Eine Komponente kann deklarieren, welche Properties sie erwartet</em>
        <ul>

          <li class="fragment">Name und Typ wird angegeben (<a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank">Mögliche Typen</a>)
          <li class="fragment">Fehlende / falsche Properties führen zu Laufzeitfehlern
          <li class="fragment">Ab React 15.5 eigenes npm modul: <a href="https://www.npmjs.com/package/prop-types" target="_blank"><code>prop-types</code></a></li>
          <li class="fragment">Alternative: Typsystem (<a href="https://flow.org" target="_blank">Flow</a> oder <a href="https://typescriptlang.org" target="_blank">TypeScript</a>)
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component { . . . };

GreetingDetail.propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onSave: PropTypes.func.isRequired
};
</code></pre>
      </section>
      <section>
        <h3>PropTypes</h3>
        <p>Mit statischen Properties (<code>static</code> noch kein JS Standard!)</p>
        <pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

class GreetingDetail extends React.Component {
  static propTypes = {
    greeting: PropTypes.shape({
      name: PropTypes.string.isRequired,
      greeting: PropTypes.string.isRequired
    }),
    onSave: PropTypes.func.isRequired
  };

  render() { . . . }
};
            </code></pre>
      </section>
      <section>
        <h3>PropTypes</h3>
        <p>Für Komponenten als Funktionen</p>
        <pre><code class="javascript" contenteditable data-trim>
import PropTypes from 'prop-types';

function HelloMessage(text) { . . . }
HelloMessage.propTypes = {
  text: PropTypes.string.isRequired
}
            </code></pre>
      </section>
        <section>
          <section>
            <h2>Übung: Eine komplette Anwendung zusammen setzen</h2>
            <h3>Füge deinen bestehenden Detail-View (<code>GreetingDetail</code>) und einen Master-View über eine Controller-Komponente zusammen</h3>
          </section>
          <section>
            <h3>Schritte</h3>
            <ol>
              <li>kopiere das Material aus <code>code/material/2-hierarchy</code> in deinen src-Ordner
              <li>erweitere im <code>GreetingController</code> die render-Methode, so dass dein <code>GreetingDetail</code> angezeigt wird, wenn der Benutzer den Add-Button klickt:
                <ul>
                  <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
                  <li>übergib einen Callback der <code>addGreeting</code> nutzt
                </ul>
              <li>im deinem <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
                <br><span style="font-size:85%">(Du kannst dein <code>GreetingDetail</code> verwenden, oder die Vorlage code/material/2-hierarchy/src/_GreetingDetail.js verwenden)</span>

            </ol>
          </section>
            <section>
                <h3>Architektur Beispiel-Anwendung</h3>
                <img src="ai/greeting-hierarchy.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingMaster</h3>
                <img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingDetail</h3>
                <img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
        </section>

        <section id="t3">
            <h1>Teil III</h1>
            <h2>Remote-Calls gegen Server</h2>
            <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h3>Herausforderungen</h3>
            <ul>
                <li>Wo speichern wir?
                <li>Wie machen wir das Laden und Speichern technisch?
                <li>Wie funktioniert asynchrone Verarbeitung in React?
                <li>Wo steht der Code zum initialen Laden der Grüße?
            </ul>
        </section>
      <section>
        <h3>Server-Calls</h3>
        <ul>
          <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
          <li>Häufig in React verwendet: <b>fetch</b> API
            <ul>
              <li>Browser-API zum Ausführen von HTTP Requests</li>
              <li><a href="http://caniuse.com/#search=fetch" target="_blank">Hohe Verbreitung</a></li>
              <li>Spezifikation: <a href="https://fetch.spec.whatwg.org/" target="_blank">https://fetch.spec.whatwg.org/</a></li>
              <li>Polyfill: <a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch</a></li>
            </ul>
        </ul>
      </section>


            <section>
                <h3>fetch</h3>
                <p>Browser-API zum Laden und Speichern von Daten</p>
<pre><code class="javascript" contenteditable data-trim>
fetch(url, {
    method: 'PUT',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(json => /* ... */)
.catch(ex => console.error('request failed', ex));
</code></pre>
            </section>


      <section data-state="exkurs">
        <h2>ES6: Promises</h2>
      </section>
      <section data-state="exkurs">
        <h3>Beispiel: fetch</h3>
        <pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;

return fetch(url)
    .then(response => response.json())
    .then(json => /* ... */)
    .catch(ex => console.error('request failed', ex));
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
      </section>

<!--
      <section data-state="exkurs">
        <h3>Erzeugen und asynchron reagieren</h3>
        <pre class="fragment"><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>promise.then(value => console.log(value));
// Output after 1 second: Result from promise
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Verkettete Ausführung</h3>
        <pre><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
      </section>
-->
      <section data-state="exkurs">
        <h3>Fehler führen zum Abbruch der Chain</h3>
        <h4 class="fragment">Allerdings muss man etwas tun, um das mitzubekommen</h4>
      </section>

<!--
      <section data-state="exkurs">
        <h3>Catch-Klausel im Erfolgsfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
      </section>
-->
      <section data-state="exkurs">
        <h3>Catch-Klausel im Fehlerfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
      </section>

      <section>
        <h3>fetch im Detail</h3>

        <pre><code class="javascript" contenteditable data-trim>
// 1. fetch returns a promise, that will be resolved
// with a Response object when response is received
// from server
fetch('http://localhost:7000/greetings')

// 2. the Response object contains a json() function,
// that returns the parsed JSON from the Response body
  .then(response => response.json())

// 3. with the resolved JSON object we set the
// component state (=&gt; leads to re-rendering)
  .then(json => this.setState({greetings: json})

// 4. in case something goes wrong (during request,
// request processing or rendering)
  .catch(ex => console.error('request failed', ex));
// as an alternative we could set and render an error msg:
//  .catch(ex => this.setState({error: ex})
</code></pre>
      </section>
      <section>
        <h3>Initiales Laden von Daten</h3>
        <ul>
          <li class="fragment">Komponenten können Lifecycle-Methoden haben: <a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank">
            https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle
          </a> (nur Klassen!)</li>
          <li class="fragment"><code>componentDidMount</code> wird aufgerufen, wenn Komponente ins DOM gerendert wurde</li>
          <li class="fragment">Hier werden Daten üblicherweise initial geladen:<pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) {
    // intial state (empty now)
    this.state = { greetings: [] };
  }
  componentDidMount() {
    fetch('/greetings')
      .then(response =&gt; response.json())
      .then(json =&gt; this.setState({greetings: json})
      .catch(. . .)
    ;
  }
}
                </code></pre>
        </ul>
      </section>
      <section>
        <h3>Speichern von Daten</h3>
        <p>Zum Beispiel als Folge einer Benutzerinteraktion:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  render() {
    ...
      &lt;GreetingDetail onSave={greeting => this.saveGreeting(greeting)} />
    ...
  }
  saveGreeting(greetingToBeSaved) {
    fetch('/greetings', {
      method: 'POST',
      headers: ...,
      body: JSON.stringify(greetingToBeSaved)
    })
      .then(response =&gt; response.json())
      .then(json =&gt; ...)
      .catch(. . .);
  }
}
                </code></pre>
      </section>
        <section>
            <section>
                <h2>Übung: Laden und Speichern der Daten von/auf einem Server</h2>
                <p><em>Entwickle auf Basis von fetch eine Version des GreetingControllers, der die Daten auf dem Server laden und dort wieder speichern kann</em></p>
                <p>Der Server ist bereits vorgegeben und kann mit <code>npm start</code> im Root-Verzeichnis gestartet werden. Er ist dann unter Port 7000 erreichbar</p>
        </section>
        <section>
            <h3>Schritte</h3>
            <p>Kopiere <code>code/material/3-remote/GreetingController.js</code> in deinen Arbeitsbereich
            <p>Die Serverzugriffe sollen in <code>loadGreetings</code> und <code>saveGreeting</code> erfolgen</p>
            <p>Dort sind bereits entsprechende TODOs für dich eingetragen</p>

        </section>
        </section>
        <section id="t4">
            <h1>Teil IV</h1>
            <h2>Integration mit 3rd-Party Bibliotheken</h2>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>3rd Party Libs?</h2>
            <div class="fragment">
                <p>Es gibt eine große Anzahl von sehr praktischen JavaScript-Bibliotheken</p>
                <p>Viele davon sind aber nicht als React-Komponenten entwickelt worden</p>
            </div>
            <div class="fragment">
                <p><b>Beispiele</b></p>
                <p><em>jQuery</em> und <em>jQuery</em> Plugins wie z.B. <em>Bootstrap</em></p>
                <p><em>d3</em> für interaktive SVGs und Chart Bibliotheken wie <em>nvd3</em></p>
            </div>
        </section>

        <section>
            <h3>Unser Beispiel: Verteilung der Grüße</h3>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">
                <img src="images/screenshot-nvd3.png" height="400px">
            </a>
            <p><em>nvd3</em> Pie Chart mit <em>d3</em></p>
        </section>

        <section>
            <h3>Aufgabe: Einbetten des Pie Charts in eine React-Komponente</h3>
        </section>

        <section>
            <h3>Herausforderungen?</h3>
            <ol>
                <li>Wie kommen wir an den DOM Knoten der React-Komponente?
                <li>Wie sagen wir React, dass nun NVD3 den Rest macht? Also, dass React nicht mehr neu rendern soll.
                <li>Änderungen des Zustands sollen nach wie vor richtig dargestellt werden
                <li>Ab welchem Zeitpunkt soll NVD3 das Rendern übernehmen?
                <li>Wie können wir aus NVD3 heraus auch wieder andere React-Komponenten beeinflussen?
                <li>Wie räumen wir wieder auf?
            </ol>
        </section>
      <section>
        <h3>Hintergrund: Charts mit NVD3</h3>
        <p>Basiert auf D3.js</p>
        <p>Benötigt svg DOM-Element um sich zu rendern</p>
        <p class="fragment">Stark vereinfachtes Beispiel:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>import d3 from 'd3';
import nv from 'nvd3';

// Chart erzeugen
const chart = nv.models.pieChart();
// ...Chart Config ausgelassen ...

// mit d3 rendern und mit Daten versorgen
const element = document.getElementById('chart');
d3.select(element)
  .datum(data)
  .call(chart);

// Callbacks registrieren (z.B. bei Klick auf ein Element)
chart.pie.dispatch.on("elementClick",
                       e => console.log(e.data.label));
            </code></pre>

      </section>

        <section>
            <h3>Übersicht über den Komponenten-Lifecycle</h3>
            <a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank">
                https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle
            </a>
        </section>
        <section>
            <img src="ai/lifecycle-methods-1.png" height="600px"/>
        </section>
        <section>
            <img src="ai/lifecycle-methods-2.png" height="600px" />
        </section>
      <section>
        <h3>React Lifecycle Methoden</h3>
        <ul>
          <li class="fragment"><code><b>componentDidMount()</b></code>: Komponente wurde gerendert, Elemente sind im DOM (einmalig)</li>
          <li class="fragment"><code><b>componentWillReceiveProps(nextProps)</b></code>: An die Komponente wurden neue Properties übergeben. Die neuen Properties
            werden als Parameter übergeben</li>
          <li class="fragment"><code><b>shouldComponentUpdate()</b></code>: Entscheidet, ob Komponente erneut gerendert werden soll (default: <code>true</code>)</li>
          <li class="fragment"><code><b>componentWillUnmount()</b></code>: Wird aufgerufen, bevor Komponente aus dem DOM entfernt wird (einmalig)</li>
        </ul>

      </section>

        <section>
            <h3>React Chart Komponente #1</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    render() {
        // (1) we render an empty svg and
        //     remember the reference to the DOM node
        return &lt;svg ref={c => this._chart = c}>&lt;/svg>
    }

    shouldComponentUpdate() {
        // (2) once rendered react never renders again
        return false;
    }

    componentWillReceiveProps(nextProps) {
        const {data} = nextProps;
        // (3) we still get updates of properties making it reactive
        updateNvd3Chart(this._chart, data);
    }

    // ...
}
       </code></pre>
        </section>

        <section>
            <h3>React Chart Komponent #2</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    // ...

    componentDidMount() {
        const {data, onSegmentSelected} = this.props;

        // (4) once rendered by react we create the nvd3 chart
        const chart = createNvd3Chart(this._chart, data);

        // (5) we delegate the label of clicked segment
        //     back to parent component
        if (onSegmentSelected) {
            chart.pie.dispatch.on("elementClick",
                                  e => onSegmentSelected(e.data.label));
        }
    }

    // (6) called just before destroying component
    componentWillUnmount() {
        this._d3selection.remove();
    }
}
       </code></pre>
        </section>

        <section>
            <section>
                <h2>Übung: Ein Pie-Chart integrieren</h2>
                <h3>Das Pie Chart soll eine Übersicht aller Grüße anzeigen</h3>
                <h3>Ein Klick auf ein Segment des Pie Charts soll die Liste der Grüße filtern</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/5-third-party</code> in deinen src-Ordner
                    <li>binde die Chart-Komponente in die render-Methode des <code>GreetingController</code> ein
                    <li>alle Stellen die du ändern musst sind dort bereits mit einem Kommentar versehen
                    <li>logge jeden Aufruf einer Lifecycle-Methode in der Chart-Komponente und versuche damit die Reihenfolge der
                    Aufrufe zu durchschauen
                </ul>
                <p>Zusatzaufgabe: Ein zweites Mal klicken auf das Segment soll den Filter wieder löschen</p>
            </section>
        </section>

        <section id="t5">
            <h1>Zustands-Management mit Redux</h1>
        </section>

        <section>
            <img src="images/dan.png" height="600px">
            <p><small><a href="https://twitter.com/triketora/status/862790779567304704">@triketora</a></small></p>
        </section>

        <section>
            <h2>Über Komponenten verteilter Zustand</h2>
            <img src="ai/distributed-state.png" />
        </section>

        <section>
            <h2>Render Cycle in Pure React</h2>
            <img src="images/redux-01-react-cycle-no-redux.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h2>Motivation für Zustandsmanagement</h2>
            <p class="fragment">Zustand, der über viele Komponenten verteilt ist, macht Programme kompliziert</p>
            <p class="fragment">Gemeinsame Nutzung von State in unterschiedlichen Komponenten-Hierarchien ist schwierig</p>
            <p class="fragment">Zustandmanagement und UI-Handler werden aus React-Komponenten extrahiert</p>
            <p class="fragment">Besseres SoC</p>
        </section>

        <section>
            <h2>Redux extrahiert die Verantwortlichkeiten</h2>
            <img src="images/redux-02-extracting-responsibility.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h2>Zwischenübung</h2>
            <p>Schreibe die erste Hello-World Anwendung auf Redux um</p>
            <p>Im ersten Schritt tust du dies im Plenum mit den Workshop-Leitern</p>
            <p>Dabei lernst du anhand des Live-Codings alle Bestandteile der Redux-Architektur kennen</p>
            <p>Dazu erstellen wir zusammen eine Übersicht über alle notwendigen Teile spezifisch für die Hello-World Anwendung</p>
            <p>Im zweiten Schritt baust du die Anwendung unter <code>code/material/hello-world</code> selbst noch einmal um</p>
        </section>

        <section>
            <h2>Strukturierter Überblick über alle Redux Teile</h2>
        </section>

        <section>
            <h3>Event-Handlers werden Action-Creators</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const setFilter = filter => {
    return {
        type: SET_FILTER,
        filter
    };
}
</code></pre>
            <ul>
                <li class="fragment">Action-Creators erzeugen Action-Objekte</li>
                <li class="fragment">Actions sind Kommando-artige Strukturen von Dingen, die die Applikation tun soll
                <li class="fragment">Über die dispatch-Methode des Stores werden sie an <em>alle</em> Reducer weiter gegeben
                <li class="fragment">Actions bestehen aus einem Typen und einer beliebigen Nutzlast (payload)</li>
            </ul>
        </section>

        <section>
            <h3>Action-Creators machen Server-Calls</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const loadGreeting = greetingId => dispatch => {
    fetch(BACKEND_URL+'/'+greetingId)
        .then(response => response.json())
        .then(greetings => dispatch({
            type: SET_GREETINGS,
            greetings
        });
};
</code></pre>
            <ul>
                <li class="fragment">Die Action wird nicht direkt zurück geliefert, sondern erst später dispatched</li>
                <li class="fragment">wir bekommen die dispatch Methode als Parameter, mit der wir später
                    die Action dispatchen</li>
                <li class="fragment"><em>getState</em> als zweiter Parameter, um den kompletten State abzufragen</li>
            </ul>
            <p  class="fragment"><strong>Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone Operationen
                ausführen dürfen</strong></p>
        </section>

        <section>
            <h3>Ein <em>einziger</em> Store hält den <em>kompletten</em> Zustand</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
    rootReducer // reducer
);
ReactDOM.render(
    &lt;Provider store={store}>
        &lt;GreetingController />
    &lt;/Provider>,
    mountNode
);
        </code></pre>
            <ul>
                <li class="fragment">Zentraler Teil der Anwendung
                <li class="fragment">Liefert die bereits bekannte dispatch-Methode
                <li class="fragment">Der Store wird allen Componenten über die Wrapper-Komponenten <em>Provider</em>
                    zur Verfügung gestellt
            </ul>
        </section>

        <section>
            <h3>Middleware zwischen Dispatch und Store</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
    rootReducer, // reducer
    applyMiddleware(thunk) // middleware as enhancer
);
        </code></pre>
            <ul>
                <li class="fragment">Die Thunk Middleware dient als de-facto-Standard</li>
                <li class="fragment">Gibt die dispatch-Methode and (asynchrone) Action Creators weiter
                <li class="fragment"><a href="https://github.com/gaearon/redux-thunk#whats-a-thunk" target="_blank">
                    'A thunk is a function that wraps an expression to delay its evaluation'
                </a></li>
                <li class="fragment">Middleware ist ein fortgeschrittenes Feature und meistens genügt die Thunk Middleware</li>
                <li class="fragment">Redux Dev Tools klinken sich über denselben Mechanismus ein</li>
            </ul>
        </section>

        <section>
            <h3>Reducers enthalten die Kern-(Business)-Logik</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import {combineReducers} from 'redux';

// http://redux.js.org/docs/api/combineReducers.html
export const rootReducer = combineReducers({
    greetings, // updates greeting partial state
    filter,
    mode
});
        </code></pre>
            <ul>
                <li class="fragment">Reducer sind pure Funtionen, die den alten Zustand und eine Action bekommen und einen neuen Zustand erzeugen
                <li class="fragment">Oft bearbeitet ein Reducer nur einen Teil des Zustands
            </ul>
        </section>

        <section>
            <h3>Teil-Reducer</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
const mode = (state = MODE_MASTER, action) => {
    switch (action.type) {
        case SET_MODE:
            return action.mode;
        default:
            return state;
    }
};
        </code></pre>
            <ul>
                <li class="fragment">Initialisiert seinen Teilzustand (oft mit einem Default-Parameter)</li>
                <li class="fragment">Ändert niemals zustand direkt</li>
                <li class="fragment">Sondern liefert einen neuen Zustand (manchmal teilweise als Kopie)
            </ul>
        </section>

        <section>
            <h3>Zustand mit Komponenten verbinden</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { connect } from 'react-redux';

import * as actions from './actions';

export default connect(
    state => ({
        mode: state.mode
        // ...
    }),
    actions
)(GreetingController);
            </code></pre>
            <ul>
                <li class="fragment">der Provider gibt den Store in alle Komponenten</li>
                <li class="fragment">Die Connect-Funktion extrahiert daraus Zustand, der als Property an Komponenten übergeben wird
                <li class="fragment">Action-Creators können ebenso in Komponent gegeben werden</li>
            </ul>
        </section>

        <section>
            <h3>Verwendung von Zustand und Action-Creators in verbundenen Komponenten</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        // state from store
        const {aggregatedGreetings, greetings, mode} = this.props;
        // action creators bound to dispatch from store
        const {setMode, saveGreeting, setFilter} = this.props;

        // ...
    }
}
            </code></pre>
            <ul>
                <li class="fragment">Action-Creators und Zustand werden in Properties hinein gemerged
                <li class="fragment">Diese werden mit ES6-Destructuring an den Stellen aufgelöst wo wir sie brauchen
                <li class="fragment">Die Komponenten wird nur neu gerendert wenn sich der benutzte Zustand verändert</li>
            </ul>
        </section>

        <section>
            <h3>Selektoren</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const selectGreetings = ({greetings}) => greetings;

export default connect(
    state => ({
        greetings: selectGreetings(state),
        // ...
    }),
    // ...
)(GreetingController);        </code></pre>
            <ul>
                <li class="fragment">Berechnen abgeleiteten Zustand</li>
                <li class="fragment">Oft in einer eigener Datei</li>
                <li class="fragment">Erlauben Wiederbenutzung und Caching (normalerweise
                    <a href="http://redux.js.org/docs/recipes/ComputingDerivedData.html" target="_blank">reselect</a>)</li>
            </ul>
        </section>

        <section>
            <h2>Zusammenfassung Redux-Architektur</h2>
            <img src="images/redux-03-resulting-redux-architecture.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
        <section>
            <h2>Übung: eine Redux Anwendung fertig stellen</h2>
            <h3>Es gibt bereits eine vorgebaute Redux-Anwendung, aber die Filterung über das Chart muss noch implementiert werden</h3>
        </section>
        <section>
            <h3>Schritte</h3>
            <ul>
                <li>Alles Material von <code>code/material/6-redux</code> in deinem Source-Ordner kopieren
                <li>TODOs leiten dich, die bereits in den Actions, den Reducers und dem GreetingController eingefügt sind
                <li>Erzeuge einen neuen Action-Typ und einen Action-Creator für das Setzen des Filters
                <li>Füge einen passenden Reducer zur Behandlung einer solchen Action hinzu und füge ihn als Teil-Reducer in
                    <code>combineReducers</code> hinzu
                <li>Reiche den Action-Creator von <code>GreetingController</code> in die Chart-Komponente in der du auf das
                    Filter-Event reagierst
            </ul>
        </section>
        </section>
        <section id="t6">
            <h2>Laufzeit-Optimierungen</h2>
            <p><a href="https://facebook.github.io/react/docs/optimizing-performance.html" target="_blank">https://facebook.github.io/react/docs/optimizing-performance.html</a></p>
        </section>

        <section>
            <h3>Beispiel: SVG Boxes</h3>
            <a href="code/sandbox/optimize/public" target="_blank">
                <img src="images/screenshot_svg.png" height="500px">
            </a>
            <p>Eine einzelne Box mit D'n'D verschieben</p>
        </section>

        <section>
            <h2>Change Detection auf der Ebene des Virtual DOM</h2>
            <p>bei jeder Bewegung der Maus werden alle Boxen neu gerendert</p>
            <p>Nicht direkt im DOM, sondern in einer leichtgewichtigen Datenstruktur (Virtual DOM)</p>
            <p>Änderungen im echten DOM werden aus Änderungen im Virtual DOM errechnet</p>
        </section>

        <section>
            <h2>Change Detection auf der Ebene des Models</h2>
            <p><strong>shouldComponentUpdate</strong> ist eine Lifecycle-Methode einer Komponente
                die diese Prozedur abkürzen kann</p>
            <p>das alte Modell kann mit dem neuen verglichen werden</p>
            <p><strong>immutable data structures</strong>
                (<a href="https://facebook.github.io/immutable-js/" target="_blank">immutable.js</a>) können den Vergleich beschleunigen</p>
        </section>

        <section>
            <h3>Die Box Component</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Box extends React.Component {
  shouldComponentUpdate(nextProps) {
    // simple check: every change to a box creates a new object
    const changed = this.props.box !== nextProps.box;
    return changed;
  }

  render() {
    const {box} = this.props;
    return &lt;rect data-id={box.id} x={box.x} y={box.y}
                 width="10" height="10"
                 stroke="black" fill="transparent" strokeWidth="1"/>;
  }
}
               </code></pre>
        </section>

        <section>
            <h3>Naiver Code für Modifikation einer Box</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
updateBox(id, x, y) {
    const {boxes} = this.state;
    const modifiedBox = {
        id,
        x,
        y
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/
    //            Reference/Global_Objects/Array/slice
    const boxesBefore = boxes.slice(0, id);
    const boxesAfter = boxes.slice(id + 1);
    const modifiedBoxes = [...boxesBefore, modifiedBox, ...boxesAfter];
    this.setState({
        boxes: modifiedBoxes
    });
}
               </code></pre>
            <p><a href="code/sandbox/optimize/src/App.js">Kompletter Code</a></p>
        </section>

        <section>
            <h3>Immutable.js</h3>
            <p>Immutable persistent data collections for Javascript which increase efficiency and simplicity.</p>
            <p><a href="http://facebook.github.io/immutable-js/" target="_blank">http://facebook.github.io/immutable-js/</a></p>
            <ul>
                <li>Bietet List, Set, Map, etc.
                <li>Jede Modifikaton einer Collection erzeugt ein neues Collection Objekt
                <li>Kopiert nicht die komplette Collection, sondern effiziente Erzeugung mittels
                <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank">Persistent Data Structures</a>
            </ul>
        </section>

        <section>
            <h3>Mit immutable.js</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
import {List} from 'immutable';

this.state = {
    boxes: List(boxes)
};
   </code></pre>

            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
updateBox(id, x, y) {
    const {boxes} = this.state;
    const modifiedBox = {
        id,
        x,
        y
    };
    const modifiedBoxes = boxes.set(id, modifiedBox);
    this.setState({
        boxes: modifiedBoxes
    });
}
               </code></pre>
            <p><a href="code/sandbox/optimize/src/AppImmutable.js">Kompletter Code</a></p>
        </section>

        <section>
            <h2>Build-Optimierungen</h2>
            <p>Minifizieren, Optimieren und alle React-Warnungen herauskompilieren:</p>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
webpack --optimize-minimize --define process.env.NODE_ENV=\"'production'\"
            </code></pre>
            <p><a href="http://lisperator.net/uglifyjs/" target="_blank">Nutzt Uglify</a></p>
            <p>Oder als Kurzform:</p>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
webpack -p
            </code></pre>
            <p><a href="https://webpack.js.org/guides/production-build/" target="_blank">https://webpack.js.org/guides/production-build/</a></p>
            <p style="font-size:80%">(<code>NODE_ENV="production"</code> wird nicht in der <code>webpack.config</code> gesetzt!)</p>

        </section>

        <section>
            <h2>Build-Optimierungen</h2>
            <em>"Tree Shaking": Entfernt toten Code aus dem generierten JavaScript File</em>
            <ul>
                <li class="fragment">Reduziert die Größe der Ausgabedatei</li>
                <li class="fragment">Verfügbar in Webpack 2.x</li>
                <li class="fragment">Automatisch eingeschaltet, wenn mit <code>-p</code> aufgerufen</li>
                <li class="fragment">Arbeitet auf Basis statischer Code-Analyse der ES6 Imports und Exports</li>
                <li class="fragment">Anpassung in <code>.babelrc</code>: <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
"presets": [["es2015", { "modules": false }]
            </code></pre>
                </li>
            </ul>
        </section>

        <section>
            <h2>Code Splitting</h2>
            <em>Asynchrones Nachladen von Modulen</em>
            <p><a href="https://webpack.js.org/guides/code-splitting-async/" target="_blank">https://webpack.js.org/guides/code-splitting-async/</a></p>
            <ul>
                <li>Erlaubt das dynamische Nachladen von Code-Teilen
                <li>So kann am Anfang für eine schnelle Ladezeit nur eine Minimalversion ausgespielt werden
                <li>Basiert auf <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a>, der bereits in Stage 3 ist
                <li>Weitere Teile können unmittelbar oder erst nach Nutzerinteraktion nachgeladen werden
            </ul>
        </section>

        <section>
            <h2>Beispiel Code</h2>
<pre><code data-trim>npm install babel-plugin-syntax-dynamic-import --save</code></pre>
<pre><code data-trim>
// .babelrc
"plugins": ["syntax-dynamic-import", ...]
</code></pre>
            <pre><code data-trim>
// calculator.js
export default function calculator(a, b) {
    return a+b;
}
           </code></pre>
            <pre><code class="javascript" data-trim>
import('./calculator')
    .then(calculatorModule => {
    // import calculator from './calculator';
    const calculator => calculatorModule.default
    console.log(calculator(7, 8));
});
            </code></pre>
            <p><a href="code/sandbox/code-splitting/src/GreetingController.js">Kompletter Code</a></p>
        </section>

        <section>
            <h3>Nachladen von React-Komponenten</h3>
            <ul>
                <li>Erfordert die Darstellung von Platzhaltern, bis die eigentliche Komponente da ist
                <li>Wenn die Komponente da ist, muss die umschließende Komponente neu dargestellt werden
                <li><em>forceUpdate</em> erzwingt ein Neuladen
            </ul>
            <pre><code class="javascript" data-trim>
class AsyncComponent extends React.Component {
    componentDidMount() {
        import('./Component').then(ComponentModule => {
            this.Component = ComponentModule.default;
            this.forceUpdate();
        });
    }

    render() {
        return this.Component ?
                &lt;this.Component /> :
                &lt;span>Loading...&lt;/span>;
    }
}
            </code></pre>
        </section>

        <section>
            <h2>Übung</h2>
            <p>Baue deine Anwendung so um, dass die Detail-Ansicht erst bei Bedarf nachgeladen wird</p>
            <p>Beginne mit der Version in <code>code/schritte/redux/8-redux-prod-build</code>, die bereits ein Produktionsbuild bietet</p>
        </section>

        <section>
            <h1>Ausblick</h1>
            <em>Weiterführende Themen, Fragen und Diskussion</em>
        </section>
        <section>
            <h2>Weiterführende Themen</h2>
            <ul>
                <li><a href="jest.html" target="_blank">React-Tests mit Jest und Enzyme</a> und
                    <a href="http://redux.js.org/docs/recipes/WritingTests.html" target="_blank">Redux-Tests</a>
                <li><a href="router-v3.html" target="_blank">React Router V3</a> und <a href="router-v4.html" target="_blank">React Router V4</a>
                <li><a href="2017_enterjs_advanced.html#/types" target="_blank">Typsysteme mit TypeScript und Flow</a>
                <li><a href="code/sandbox/hoc/src/HelloMessage.js" target="_blank">Higher Order Components (HoC)</a>
            </ul>
        </section>
        <section>
            <em>Vielen Dank für Eure Teilnahme!</em>
            <h2>Fragen und Diskussion</h2>
            <div style="font-size:80%; margin-top: 80px">
                <p>
                    <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>

                </p>
                <p>
                    <a href="http://zeigermann.eu" target="_blank">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose" target="_blank">@DJCordhose</a>
                </p>
            </div>

        </section>
    </div>
</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>

<script>
    Reveal.addEventListener( 'ready', function( event ) {
        if (window.location.hostname.indexOf('localhost') !== -1) {
            // only applies to presentation version
            Reveal.configure({ controls: false });
        } else {
            // only applies to public version
            $('.fragment').removeClass('fragment');
        }
        // applies to all versions
        $('code').addClass('line-numbers');
        $('li.fragment').removeClass('fragment');
    } );
</script>


<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
