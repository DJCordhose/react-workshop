<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>React Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
        .reveal pre code {
            max-height: 1000px !important;
        }

    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!--
Titel:

Einführung in die Philosophie von React

Abstract:

Dieser Workshop führt dich in die Programmierung und Philosophie von
React ein. Dabei wirst du sehen, wie React mit vielen bisher
bestehenden Best-Practices bricht und warum das so ist. Wir werden uns
daher viel Zeit für individuelle Fragestellungen und Übungen nehmen,
um dir diese Grundlagen auch nachhaltig zu vermitteln.

Am Ende es Workshops hast du eine Vorstellung davon, wie
React-Anwendungen aufgebaut sind und wie du eine neue React-Anwendung
beginnst. Du kannst ebenso einschätzen, was die Stärken und Schwächen
von React sind.

Inhaltlich wirst du lernen, React-Komponenten zu entwickeln und daraus
eine ganze Anwendung zu bauen. Dazu sehen wir uns einen typischen
Entwicklungsprozess mit Webpack und Babel an. Außerdem zeigen wir dir, wie du
Datenzugriffe auf einen Server machen und 3rd-Party-Bibliotheken in deine
Anwendung integrieren kannst. Zur Strukturierung deiner Anwendung
und der Trennung von UI und Geschäftlogik sehen wir uns das Framework "Redux"
 an, das häufig gemeinsam mit React
 eingesetzt wird.

Mit einem Ausblick auf das React-Ökosystem schließen wir den Workshop ab,
so dass du Orientierung und Ideen für weitere Themen bekommst.

Zielgruppe

Du hast bereits grundlegende Erfahrungen mit JavaScript, am besten mit
der Version ES2015. Solltest du ES2015 noch nicht kennen, keine Angst,
wir beginnen den Workshop mit einer Einführung/Wiederholung der
Sprach-Features, die du für die React-Programmierung auch wirklich
brauchst. Wir setzen keine Erfahrung mit React voraus und beginnen
tatsächlich bei Null.

Technische Voraussetzungen der Teilnehmer

Du brauchst ein Laptop, auf dem du Software installieren kannst und
das den Anforderungen moderner Software-Entwicklung gewachsen ist.
Bitte installiere vor dem Workshop Node.js (https://nodejs.org), git
(https://git-scm.com/downloads) und eine IDE. Wir empfehlen entweder
Visual Studio Code (kostenlos, https://code.visualstudio.com/), oder Webstorm
(https://www.jetbrains.com/webstorm/specials/webstorm/webstorm.html)
bzw. IDEA (https://www.jetbrains.com/idea/). Als Browser empfehlen wir
Chrome, es tut aber auch Firefox, Safari oder der aktuelle
Edge-Browser von Microsoft.


Mögliche Agenda (grob, ohne Pausen):

- Teil 1 (3 Stunden)
  - Einführung in React
  - Build-Prozess
  - ES6-Grundlagen
  - React Komponenten
  - Komponentenhierarchien

- Teil 2 (2 Stunden) Serverzugriffe
 - Die fetch-Bibliothek
 - ES6 Promises
 - Lebenszyklus von React Komponenten

- Teil 3 (2 Stunden) Integration mit 3rd-Party-Apps
 - Referenzen in React
 - Zugriff von React auf 3rd-Party Lib
 - Zugriff von Lib auf React-Komponente


- Teil 4 (3 Stunden): Redux
 - Motivation: Trennung von UI und Logik, nachvollziehbarerer Datenfluss etc
 - (Einführung Flux?)
 - Einführung Redux / Redux im Überblick
 - Action, Action Creator, Reducer
 - Verbinden von Komponenten
 - Store (mehrere Reducer)
 - Middleware / Asynchrone Aufrufe mit thunk

- Teil 5 (1 Stunde): Performance Optimierung
 - Immutable / shouldComponentUpdate (Immutable ggf schon vorher)
 - Prod-Build

- Teil 6 (1 Stunde)
 - Ausblick / Überblick über weiteres React Öko-System

Zeitplan:
Tag 1:

ab 10 Uhr Registrierung
11 Uhr Beginn Workshop
12.30 - 13.30 Uhr Mittagessen
13 - 14 Uhr Mittagessen
15.30  - 15.45 Uhr: 1. Kaffeepause
17.15 - 17.30 Uhr: 2 Kaffeepause
Ende gegen 18.30 Uhr

Tag 2:

9 Uhr Beginn
10.45 - 11.00 Uhr: Kaffeepause
12.30 - 13.30 Uhr: Mittagessen
15.00 - 15.15 Uhr: Kaffeepause
Ende gegen 16.30 Uhr



  -->

    <!--http://dpunkt.de/lecture.php?event_id=3536-->

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h3>React Workshop - Vorbereitung</h3>
            <p>Falls noch nicht gemacht:</p>
            <ol>
                <li><code>git clone https://github.com/DJCordhose/react-workshop.git</code></li>
                <li>Im geklonten Verzeichnis: <code>npm install</code></li>
                <li>Im geklonten Verzeichnis: <code>npm run setup</code></li>
                <li>In <code>code/workspace</code> wechseln</li>
                <li>Ausführen: <code>npm start</code></li>
                <li>Browser öffnen: <a href="http://localhost:8080" target="_blank">http://localhost:8080</a></li>
            </ol>
            <p>Folien: Im geklonten Verzeichnis <code>2017_ix.html</code>
            </p>
        </section>
        <section>
            <h1>React Workshop</h1>
            <p>
                <small><a href="http://nilshartmann.net">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann">@nilshartmann</a>
                </small>
            </p>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <p><small><a href="http://bit.ly/react-ix">http://bit.ly/react-ix</a></small></p>

        </section>

        <section>
            <h2>Inhalt</h2>
            <ul>
                <li><a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
                <li><a href="#/t1">Teil I: React-Komponenten und ES6 Grundlagen</a>
                <li><a href="#/t2">Teil II: Komponentenhierarchien</a>
                <li><a href="#/t3">Teil III: Remote-Calls gegen Server</a>
                <li><a href="#/t4">Teil IV: Integration mit 3rd-Party Libs</a>
                <li><a href="#/t5">Teil V: Redux</a>
<pre class="todo">
- Als Motivation:
    - Abstraktionen können helfen: https://twitter.com/deech/status/831606407011115008?s=03
    - Twitter nutzt Redux: https://medium.com/statuscode/dissecting-twitters-redux-store-d7280b62c6b1#.8vi5orv9r
- Zähler als dritte Komponente vorgeben
  - x (gefiltert)/y (insgesamt)
- Einleitende Übung für Flux / Redux
- Komplette Anwendung, damit klar ist, wie sie funktioniert
  - keinen Code zeigen
  - Herausforderungen
    - Verteilte Logik
       - Aggreation in Chart
       - Filterung in Controller
       - Counter
       - Server Aufruf
    - Sicher stellen, dass alle drei Darstellungen konsistent sind
    - Controller ist Gottkomponente
       - mit aller Business-Logic
       - und allem "fachlichem" State (Liste der Grüße)
       - und allem UI-State (welche Komponente wird angezeigt, wonach wird gefiltert)
       - Wissen über Layout
    - Transformierte Daten müssen bei jedem Rendering erneut errechnet werden (auch wenn gar nicht notwendig)
    - Möglichkeiten diskutieren
      - I: Smart-, Dumb-Komponent (wie gehabt)
      - II: Event-Bus mit verteiltem State
        - Wie wird der initiale State gesetzt?
        - Wie geht man mit einer Komponente um, die erst später hinzugefügt wird?
      - III: Flux
        - State und Logik zentral in Store ziehen
        - Server-Call in Action Creator
        - 2 Optionen
          - Controller bleibt und registriert an Store, dispatcht actions
          - Controller verschwindet, store übernimmt seine Aufgabe
            - Dumb Componentes
      - IV: Redux
</pre>
                <li><a href="#/t6">Teil VI: Performance</a>
<pre class="todo">
- https://facebook.github.io/react/docs/optimizing-performance.html
- shouldComponentUpdate: In unserem Fall:
  - Redux macht den Check
  - Wir haben aber nur genau einen Zustand, daher macht ein shouldComponentUpdate so keinen Sinn
  - Wir brauchen ein besseres Beispiel
    - Default: Einzelnen Eintrag aus Liste herausziehen
- Prod build
- Reselect
- immutable.js
</pre>

                <li><a href="#/t7">Teil VII: Ausblick</a>
                <h2>Ausblick</h2>
                <pre class="todo">
1-1,5 Kino zum Abschluss

- TypeScript Flow
- Eslint?
- React Native
- Neuer React Kern: https://github.com/acdlite/react-fiber-architecture
- Router (falls noch nicht vorher passiert)
    - Jest (falls noch nicht vorher passiert)
- Flux / Redux (falls noch nicht vorher passiert)
- Server Side Rendering
- GraphQL und Relay
- Auth???? https://dzone.com/articles/adding-authentication-to-a-web-application-with-au?edition=261708&utm_source=Spotlight&utm_medium=email&utm_campaign=web%20dev%202017-01-05
            </pre>
x
            </ul>
        </section>

        <section class="todo">
            <ul>
                <li>Zeilennummern für Code Beispiele
                <li>Teil 3 (Server) neu bauen mit express API (Daten in Memory halten), lokale Installation
                <li>Upgrade auf neuestes React
                <li>Upgrade auf Webpack 2
                <li>Buildprozess mehr Folien</li>
                <li>Was in TODO.md steht
                <li>Computed Properties erklären in Folie oder aus dem Beispiel herausnehmen
            </ul>
        </section>
        <!--<section>-->
            <!--<h3>Plan</h3>-->
            <!--<ul>-->
                <!--<li>11:00 - 11:30: Teil 0: React-Einführung und Build-Prozess-->
                <!--<li>11:30 - 12:30: Teil 1: React-Komponenten, ES6 Grundlagen-->
                <!--<li><em>12:30 - 13:30: Mittagessen</em>-->
                <!--<li>13:30 - 14:00: Übung für Teil 1-->
                <!--<li>14:00 - 14:30: Teil 2: Komponentenhierarchien-->
                <!--<li>14:30 - 15:00: Übung für Teil 2-->
                <!--<li><em>15:00 - 15:15: Kaffeepause</em>-->
                <!--<li>15:15 - 15:45: Teil 3: Testen (optional mit kleiner Übung)-->
                <!--<li>15:45 - 16:15: Teil 4: React Router-->
                <!--<li>16:15 - 16:45: Übung für Teil 4-->
                <!--<li><em>16:45 - 17:00: kleine Kaffeepause</em>-->
                <!--<li>17:00 - 17:30: Teil 5: Remote-Calls gegen Server-->
                <!--<li>17:30 - max. 18:00: Ausblick/Fragen/Abschluss-->
            <!--</ul>-->
        <!--</section>-->

        <section id="t0">
            <h1>Teil 0</h1>
            <h2>React-Einführung und Build-Prozess</h2>
        </section>

        <section id="react">
            <h2>React</h2>
            <ul>
                <li class="fragment">Framework für Facebook und viele andere
                <li class="fragment">Komponenten kapseln Template und Logik
                  <li class="fragment">Deklarativ
                <li class="fragment">Abstraktion vom DOM: <em>f(model) -> UI</em>
                <li class="fragment">Minimales API
                <li class="fragment">Ein-Weg-Data-Binding: Zustandsänderungen stellen Komponente <b>komplett</b> neu dar
                <li class="fragment">Kann im Browser und auf dem Server rendern
                <!--<li class="fragment">wird für komplette Anwendung typischerweise mit React Router und einem Flux-Framework gekoppelt-->
                <!--<li class="fragment">viel Inspiration aus der funktionalen Ecke (Immutable, pure functions, stateless)-->
            </ul>
        </section>

        <section>
            <h3>React Komponenten</h3>
            <ul>
                <li class="fragment">Werden als ES6 Klasse oder Funktion implementiert
                <li class="fragment">Keine Templatesprache (stattdessen JavaScript)
                <li class="fragment">Templates können HTML-artige Syntax enthalten (JSX)
            </ul>
            <pre class="fragment"><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return &lt;h1 className='title'>Hello, World!&lt;/h1>
  }
}
</code></pre></section>

        <section>
            <h3>Hello World React</h3>
                <a target="_blank" href="code/hello_world/public/index.html">Demo</a>
        </section>

        <section>
                <section>
                    <h3>Hello World React</h3>
<pre><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return (&lt;div>
            &lt;input ref={input => this.input = input}
                   onChange={event => this.updateModel(event)}
                   value={this.state.greeting} />
            &lt;p>{this.state.greeting}, World&lt;/p>
            &lt;button
                onClick={() => this.reset()}>
                Clear
            &lt;/button>
        &lt;/div>);
  }</code></pre>
<pre class="fragment"><code contenteditable class="javascript">  constructor(props) {
    super(props);
    this.state = {greeting: this.props.greeting};
  }
  updateModel(event) {
    this.setState({greeting: event.target.value});
  }
  reset() {
    this.setState({greeting: ""});
    this.input.focus();
  }
}</code></pre>
                </section>

            <section>
                <h3>ES6: Klassen</h3>
                <pre class="fragment"><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return this.name + " codes in " + this.language;
    }
}</code></pre>
                <pre><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
            </section>



            <section>
            <h3>ES6: Arrow Functions</h3>
            <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable>const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
        </section>

                <!--<section>-->
                    <!--<h3>ES6: Lexcial Binding an this bei Arrow-Functions</h3>-->
<!--<pre><code class="javascript" contenteditable data-trim="">-->
<!--const obj = {-->
    <!--methodOfObj: function () {-->
      <!--console.log(`In Method: ${obj === this}`); // true-->
        <!--['1', '2', '3'].forEach( e => {-->
           <!--console.log(`In Loop: ${obj === this}`); // true-->
        <!--});-->
    <!--}-->
<!--};-->

<!--obj.methodOfObj();-->
<!--</code></pre>-->
            <!--</section>-->


        </section>

        <section>
                    <h3>Aufruf</h3>
<pre><code data-trim contenteditable>
// index.html
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
<pre class="fragment"><code data-trim contenteditable class="javascript">
// main.js
import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage greeting="Hello"/>, mountNode);
</code></pre>
                    <a target="_blank" href="code/hello_world/public/index.html">Run</a>
                </section>


    <section>
        <h2>Buildprozess</h2>
        <ul>
            <li>ES6- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <li>Typische Werkzeuge
                <ul><li>Babel (Compiler)
                    <li>Webpack (Bundler)
                    <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
                    </ul>
        </ul>
    </section>
     <section>
        <h2>Webpack und Babel</h2>
        <img src="webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0"/>
    </section>

    </section>
    <section>
      <section>
          <h2>Übung 0: React Hello-World</h2>
          <h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
      </section>
      <section>
          <h3>Schritt #1: Tool-Chain starten</h3>
          <p>Nutze das <code>workspace</code>-Verzeichnis in diesem Repository</p>
          <p>Hier ist eine Tool-Chain mit Webpack und Babel vorbereitet</p>
          <ul>
              <li>Evtl. dafür einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a></li>
              <li><code>npm install</code> (auf oberster Ebene)
              <li><code>npm run setup</code> (auf oberster Ebene)
              <li><code>cd code/workspace</code>
              <li><code>npm run devserver</code>
              <li>Öffne <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
              <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
          </ul>
      </section>
      <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <ul>
              <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel aus den Folien
              <li>Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.
                  <ul>
                      <li>Alle Eingaben sollen in Großbuchstaben auftauchen
                      <li>Gib irgendeine Rückmeldung wenn die Eingabe erfolgreich gelöscht wurde
                  </ul>
          </li>
          </ul>
      </section>
    </section>

        <section id="t1">
            <h1>Teil I</h1>
            <h2>React-Komponenten und ES6 Grundlagen</h2>
            <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>Rendering
                <li>Properties und Zustand
                <li>Refs
            </ul>
        </section>

        <section>
            <h2>ES6-Referenz</h2>
            <p><a href="http://exploringjs.com/es6/" target="_blank">
                http://exploringjs.com/es6/
            </a>
        </section>

            <section>
                <h3>React: Rendering</h3>
                <ul class="fragment">
                    <li>Jede React-Komponente braucht eine <code>render</code>-Methode:</li>
                    <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
                    <li>kann HTML-artige JSX-Syntax nutzen</li>
                    <li>JSX kann pures JavaScript in geschweiften Klammern enthalten (<code>{}</code>)
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={input => this.input = input}
           onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
        </section>
           <section>
                <h3>React: Rendering #2</h3>
                <ul class="fragment">
                    <li>DOM-Events werden in React-Events verpackt
                    <li>React-Events haben weitgehend selbe API wie DOM-Events
                    <li>Es gibt keine automatische Bindung an Modelle
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={input => this.input = input}
               onChange={event => this.updateModel(event.target.value)}
               value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  updateModel(greeting) {
    this.setState({greeting});
  }
  // ...
}
</code></pre>
        </section>
        <section>
            <h3>ES6: Erweiterte Objekt-Literale</h3>
   <pre><code class="javascript" contenteditable>const name = 'Oma';
const person = {
    // ES5: name: name
    name
};
console.log(person.name); // Oma
   </code></pre>
        </section>


                    <section>
                        <h2>ES6: Module, Importe und Exporte</h2>
                    </section>
                    <section>
                        <h3>ES6: Export einer einzigen Klasse</h3>
   <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Import</h3>
   <pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Benannte Exporte</h3>
   <pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}
// or
export { displayInPage };
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
<!--display('Hello, World');-->
   <!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
<!--util.displayInPage('Hello, World');-->
   <!--</code></pre>-->
                    </section>
        <!--<section>-->
                        <!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
                    <!--</section>-->

                    <!--<section>-->
                      <!--<h3>Tagged Template Literals</h3>-->
          <!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
         <!--Mini-DSLs: Template-Literals mit tag-->
    <!--</a>-->
    <!--</p>-->

   <!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
  <!--console.log(strings);-->
  <!--//[ '', ' codes in ', '.' ]-->
  <!--console.log(values);-->
  <!--//[ 'Oma', 'Haskell' ]-->
  <!--return 'whatever you want';-->
<!--}-->
<!--</code></pre>-->

   <!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
<!--console.log(expanded);-->
<!--//whatever you want-->
<!--</code></pre>-->

                    <!--</section>-->

                    <section>
                        <h3>ES6: Destructuring von Objekten</h3>
   <pre><code class="javascript" contenteditable>const person = {
  name: 'Olli',
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable>const {name, notThere} = person;
console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
   <!--<pre class="fragment"><code class="javascript" contenteditable>const {address: {city}} = person;-->
<!--console.log(`city=${city}`);-->
<!--//city=Hamburg-->
<!--</code></pre>-->
                    </section>
                    <!--<section>-->
                        <!--<h3>Destructuring bei Parametern</h3>-->
   <!--<pre><code class="javascript" contenteditable>const person = {-->
  <!--name: 'Olli',-->
  <!--address: {-->
    <!--city: 'Hamburg'-->
  <!--},-->
  <!--email: 'oliver.zeigermann@gmail.com'-->
<!--};</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--function print({email: contact}) {-->
    <!--console.log(`contact=${contact}`);-->
<!--}-->
<!--print(person);-->
<!--// contact=oliver.zeigermann@gmail.com-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--function g({name: x, y, z=10}) {-->
  <!--console.log(`x=${x}`); // x=olli-->
  <!--console.log(`y=${y}`); // y=undefined-->
  <!--console.log(`z=${z}`); // z=10-->
<!--}-->
<!--g({ name: 'olli' });-->
<!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>Destructuring bei Arrays</h3>-->
   <!--<pre><code class="javascript" contenteditable>const [a, b] = [1, 2];-->
<!--console.log(`a=${a}`);-->
<!--// a=1-->
<!--console.log(`b=${b}`);-->
<!--// b=2-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--const [, b] = [1, 2];-->
<!--console.log(`b=${b}`);-->
<!--//b=2-->
<!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>Erweiterte Objekt-Literale</h3>-->
   <!--<pre><code class="javascript" contenteditable>const name = 'Oma';-->
<!--const person = {-->
    <!--// ES5: name: name-->
    <!--name,-->
    <!--// ES5: toString: function()-->
    <!--toString() {-->
        <!--return this.name;-->
    <!--}-->
<!--};-->
<!--console.log(person.name); // Oma-->
<!--console.log(person.toString()); // Oma-->
   <!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>for..of</h3>-->
          <!--<p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">-->
         <!--Iterieren über alles was 'iterable' ist-->
    <!--</a>-->
    <!--</p>-->

   <!--<pre><code class="javascript" contenteditable>for (const e of array2) {-->
    <!--console.log(e);-->
<!--}-->
<!--// Hi-->
<!--// Olli-->
<!--// how are you-->
<!--// ?-->
<!--</code></pre>-->
                    <!--</section>-->

    <!--<section>-->
                        <!--<h3>Spread-Operator</h3>-->
          <!--<p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">-->
          <!--Alles was 'iterable' ist kann in einzelne Parameter transformiert werden-->
    <!--</a>-->
    <!--</p>-->
   <!--<pre><code class="javascript" contenteditable>const array1 = ['Olli', 'how are you'];-->
<!--const array2 = ['Hi', ...array1, '?'];-->
<!--console.log(array2);-->
<!--// => ["Hi", "Olli", "how are you", "?"]-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable>console.log(...array1);-->
<!--</code></pre>-->
                    <!--</section>-->

                <!--<section>-->
                    <!--<h2>Verbesserungen bei Funktionen in ES6</h2>-->
                <!--</section>-->


        <section>
            <h3>React: Properties und Zustand</h3>
            <ul class="fragment">
                <li><b>Properties</b> werden der Komponente von <b>außen</b> übergeben (und nicht verändert)</li>
                <li><b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
                <li>Beides sind Objekte mit Key-Value-Paaren</li>
                <li>Beide können an Unterkomponenten übergeben werden</li>
            </ul>
        </section>

        <section>
            <h3>Properties einer Komponente</h3>
            <ul class="fragment">
                <li>Properties werden von außen über den Konstruktor übergeben</li>
                <li>Properties dürfen nicht verändert werden</li>
                <li>Zugriff über <code>this.props</code></li>
            </ul>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
class TitleComponent extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
      return &lt;h1>{this.props.title}&lt;/h1>
    }
   // ...
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
  &lt;TitleComponent title='Hello World' />
</pre></code>

        </section>

        <section>
            <h3>Zustand einer Komponente</h3>
            <ul class="fragment">
                <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server</li>
                <li>Werte üblicherweise immutable</li>
                <li>Initialisieren im Konstruktor mit <code>this.state={}</code>
                <li>Zustand <b>lesen</b> über <code>this.state</code>
                <li>Zustand <b>setzen</b> über <code>this.setState()</code>
                <ul><li>kein "reiner" Setter</li>
                    <li>Führt alten und neuen Zustand zusammen</li>
                    <li><b>Löst erneutes rendern der <i>gesamten</i> Komponente aus</b></li>
                </ul>
            </ul>
            </section>

            <section>
                <h3>Beispiel: Zustand einer Komponente</h3>
<pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
        </section>
        <section>
            <h3>Render Zyklus</h3>
            <img src="event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Virtual DOM</h3>
            <img src="virtual-dom.png" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>React: Refs</h3>
            <ul class="fragment">
                <li>Beim rendern kann man an eine Referenz des unterliegenden DOMs kommen
                <li>die DOM-Referenz kann einer Funktion übergeben werden
                <li>Diese Referenz kann man z.B. als Member-Variable speichern
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
    render() {
        return (
            <div>
                &lt;input ref={input => this.input = input} />
                &lt;button
                    onClick={() => this.input.focus()}>
                    Focus
                &lt;/button>
            </div>);
    }
}
</code></pre>
        </section>

    <section>
      <section>
          <h2>Übung 1: Detail-Ansicht für unsere Gruß-Anwendung</h2>
          <h3>Erzeuge eine Komponenten mit der man einen Namen und eine Grußformel eingeben kann</h3>
      </section>
      <section>
          <h3>Schritte</h3>
          <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
          <ul>
              <li>benenne deine Komponente in <code>GreetingDetail</code> um
              <li>du brauchst zwei Eingabefelder, die <code>name</code> und <code>greeting</code> im Zustand der Komponente setzen
              <li>für etwas Styling kopiere das Material in <code>code/material/1-detail</code> in deinen <code>public</code>-Ordner
              <li><em>Zusatzaufgabe: Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand initialisieren</em>
          </ul>
      </section>
    </section>


        <section id="t2">
            <h1>Teil II</h1>
            <h2>Komponentenhierarchien</h2>
            <h3>Komplette Anwendung aus Komponenten bauen</h3>
            <a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Referenz</h2>
            <p><a href="https://facebook.github.io/react/docs" target="_blank">
                https://facebook.github.io/react/docs
            </a>
            </p>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>Komponenten als Funktion
                <li>Darstellung von Listen und Keys
                <li>Architektur-Idee: Controller-Komponente und View-Komponente
                <li>Durchreichen von Zustand und Callbacks
                <li>PropTypes
            </ul>
        </section>

            <section>
                <h3>Komponenten als Funktion</h3>
                <ul class="fragment">
                    <li>Komponente ist eine einfache Funktion</li>
                    <li>entspricht der <code>render</code>-Methode</li>
                    <li>Properties werden als Parameter übergeben</li>
                    <li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
function Layout(props) {
  return (
      <div className="Main">
        <div className="Container">
          {props.children}
        </div>
      </div>
  );
}
</code></pre>
        </section>

            <section>
                <h3>Listen und Keys</h3>
                <ul class="fragment">
                    <li>JSX bietet nichts für Listen
                    <li>Ausgabe typischerweise über <code>Array.map</code>
                    <li>Elemente einer Liste brauchen einen eindeutigen key
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [{
    id: 0,
    name: 'Olli',
    greeting: 'Huhu'
},
{
    id: 1,
    name: 'Oma',
    greeting: 'Hallo'
}
];
const body = greetings.map(greeting =>
    &lt;tr key={greeting.id}>
        &lt;td>{greeting.name}</td>
        &lt;td>{greeting.greeting}</td>
    &lt;/tr>);
</code></pre>
        </section>

        <section>
            <h3>Controller und Child-Views</h3>
            <img src="controller.png" height="600" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Durchreichen vom Zustand und Callbacks</h3>
            <ul class="fragment">
                <li>Funktioniert beides über Properties
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        const {greetings} = this.state;
        return (
            <div>
                &lt;GreetingMaster greetings={greetings}
                    onAdd={() => this.setState({mode: MODE_DETAIL})}
            </div>);
    }
    // ...
}
    </code></pre>
    </section>
    <section>
        <h3>Properties übergeben mit Object-Spread</h3>
        <ul class="fragment">
                <li>Übergibt <b>alle</b> Eigenschaften eines Objektes als individuelle Properties</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {

    const greeting = { name: 'Klaus', greeting: 'Hello' };

    render() {
        return &lt;GreetingDetail {...greeting} />

        // entspricht:
        // &lt;GreetingDetail name='Klaus' greeting='Hello' />
    }
}
        </code></pre>
    </section>

        <section>
            <h3>PropTypes</h3>
                <ul class="fragment">
                    <li>Eine Komponente kann deklarieren, welche Properties sie erwartet
                    <li>Auch der Typ kann angegeben werden
                    <li>Fehlende / falsche Properties führen zu Laufzeitfehlern
                    <li><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank">Mögliche Typen</a>
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
GreetingDetail.propTypes = {
    greeting: PropTypes.shape({
      name: React.PropTypes.string.isRequired,
      greeting: React.PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
};
</code></pre>
        </section>

        <section>
            <section>
                <h2>Übung 2: Eine komplette Anwendung zusammen setzen</h2>
                <h3>Füge deinen Detail-View und einen Master-View über eine Controller-Komponente zusammen</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/2-hierarchy</code> in deinen src-Ordner
                    <li>erweitere im <code>GreetingController</code> die render-Methode, so dass dein Detail-View angezeigt wird, wenn der Benutzer den Add-Button klickt
                    <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
                    <li>übergib einen Callback der <code>addGreeting</code> nutzt
                    <li>im deinem <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
                </ul>
            </section>
            <section>
                <h3>Architektur Beispiel-Anwendung</h3>
                <img src="greeting-hierarchy.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingMaster</h3>
                <img src="greeting-master.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingDetail</h3>
                <img src="greeting-detail.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
        </section>

        <section id="t3">
            <h1>Teil III</h1>
            <h2>Remote-Calls gegen Server</h2>
            <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <section>
                <h2>Übung 5: Laden und Speichern der Daten von/auf einem Server</h2>
                <h3>Entwickelt gemeinsam mit den Workshop-Leitern eine Version, die die Grüße über eine id darstellen kann</h3>
            </section>

            <!--Idee: gemeinsam Live entwickeln und dabei die Punkte herausarbeiten-->
            <!-- - wie macht man das laden und speichern technisch: fetch vorgeben-->
            <!-- - wie funktioniert asynchrones?-->
            <!-- - wo lädt man die Daten eigentlich: live cycle methoden-->
            <!-- - was macht man mit der id?-->
            <section>
                <h3>Herausforderungen</h3>
                <ul>
                    <li>Wo speichern wir?
                    <li>Wie machen wir das Laden und Speichern technisch?
                    <li>Wie funktioniert asynchrone Verarbeitung in React?
                    <li>Wo steht der Code zum Laden der Grüße?
                </ul>
            </section>

            <section>
                <h3>Material: Firebase</h3>
                <ul>
                    <li><code>https://gruss.firebaseio.com/</code>: Admin-Interface der Firebase DB
                    <li><code>curl 'https://gruss.firebaseio.com/rest/greetings.json'</code> greetings holen
                    <li><code>curl -X PUT -d '[{ "id": 1, "name": "Oma", "greeting": "Hiho"}, {"id": 2, "name": "Opa"}]' 'https://gruss.firebaseio.com/rest/greetings.json'</code> greetings speichern
                    <li><code>curl 'https://gruss.firebaseio.com/rest/greetings.json?orderBy="id"&equalTo=3'</code> greeting über id laden
                </ul>
            </section>
            <section>
                <h3>Material: fetch</h3>
<pre><code class="javascript" contenteditable data-trim>
fetch(url, {
    method: 'PUT',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(json => /* ... */)
.catch(ex => console.error('request failed', ex));
</code></pre>
            </section>
        </section>


        <!--<section>-->
            <!--<h2>Optionale Übung: Remote Calls</h2>-->
            <!--<h3>Lade und Speichere Grüße vom/auf dem Server</h3>-->
        <!--</section>-->

        <section>
            <h2>Optional: Promises</h2>
        </section>
                <section>
                        <h3>fetch</h3>
<pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;

return fetch(url)
    .then(response => response.json())
    .then(json => /* ... */)
    .catch(ex => console.error('request failed', ex));
</code></pre>
                </section>
                    <section>
                        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
                        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
                    </section>

                <section>
                        <h3>Erzeugen und asynchron reagieren</h3>
   <pre class="fragment"><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre><code class="javascript" contenteditable>promise.then(value => console.log(value));
// Output after 1 second: Result from promise
</code></pre>
                    </section>
                    <section>
                        <h3>Verkettete Ausführung</h3>
   <pre><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
                    </section>
            <section>
                <h3>Fehler führen zum Abbruch der Chain</h3>
                <h4 class="fragment">Allerdings muss man etwas tun, um das mitzubekommen</h4>
            </section>

                    <section>
                        <h3>Catch-Klausel</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
                    </section>
                    <section>
                        <h3>Catch-Klausel im Fehlerfall</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
                    </section>
                    <section>
                        <h3>Catch-Klausel bei Ablehnung</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly rejects promise
    .reject('Promise rejected')
    .then(x => {
        // this will NOT be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// error:  Promise rejected</code></pre>
                </section>

        <section id="t4">
            <h1>Teil IV</h1>
            <h2>Integration mit 3rd-Party Bibliotheken</h2>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>3rd Party Libs?</h2>
            <div class="fragment">
                <p>Es gibt eine große Anzahl von sehr praktischen JavaScript-Bibliotheken</p>
                <p>Viele davon sind aber nicht als React-Komponenten entwickelt worden</p>
            </div>
            <div class="fragment">
                <p>Beispiels</p>
                <p><em>jQuery</em> und <em>jQuery</em> Plugins wie z.B. <em>Bootstrap</em></p>
                <p><em>d3</em> für interaktive SVGs und Chart Bibliotheken wie <em>nvd3</em></p>
            </div>
        </section>

        <section>
            <h3>Unser Beispiel: Verteilung der Grüße</h3>
            <a href="code/schritte/5-third-party/public/index.html" target="_blank">
                <img src="screenshot-nvd3.png" height="400px">
            </a>
            <p><em>nvd3</em> Pie Chart mit <em>d3</em></p>
        </section>

        <section>
            <h3>Aufgabe: Einbetten des Pie Charts in eine React-Komponente</h3>
        </section>

        <section>
            <h3>Herausforderungen?</h3>
            <ol>
                <li>Wie kommen wir an den DOM Knoten der React-Komponente?
                <li>Wie sagen wir React, dass nun NVD3 den Rest macht? Also, dass React nicht mehr neu rendern soll.
                <li>Änderungen des Zustands sollen nach wie vor richtig dargestellt werden
                <li>Ab welchem Zeitpunkt soll NVD3 das Rendern übernehmen?
                <li>Wie können wir aus NVD3 heraus auch wieder andere React-Komponenten beeinflussen?
            </ol>
        </section>
        <section>
            <h3>React Chart Komponente #1</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    render() {
        // (1) we render an empty svg and
        //     remember the reference to the DOM node
        return &lt;svg ref={c => this._chart = c}>&lt;/svg>
    }

    shouldComponentUpdate() {
        // (2) once rendered react never renders again
        return false;
    }

    componentWillReceiveProps(nextProps) {
        const {data} = nextProps;
        // (3) we still get updates of properties making it reactive
        updateNvd3Chart(this._chart, data);
    }

    // ...
}
       </code></pre>
        </section>

        <section>
            <h3>React Chart Komponent #2</h3>
            <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
class Chart extends React.Component {
    // ...

    componentDidMount() {
        const {data, onSegmentSelected} = this.props;

        // (4) once rendered by react we create the nvd3 chart
        const chart = createNvd3Chart(this._chart, data);

        // (5) we delegate the label of clicked segment
        //     back to parent component
        if (onSegmentSelected) {
            chart.pie.dispatch.on("elementClick",
                                  e => onSegmentSelected(e.data.label));
        }
    }
}
       </code></pre>
        </section>

        <section>
            <section>
                <h2>Übung: Ein Pie-Chart integrieren</h2>
                <h3>Das Pie Chart soll eine Übersicht aller Grüße anzeigen</h3>
                <h3>Ein Klick auf ein Segment des Pie Charts soll die Liste der Grüße filtern</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/4-3rd-party</code> in deinen src-Ordner
                    <li>binde die Chart-Komponente in die render-Methode des <code>GreetingController</code> ein
                    <li>alle Stellen die du ändern musst sind dort bereits mit einem Kommentar versehen
                </ul>
                <p>Zusatzaufgabe: Ein zweites Mal klicken auf das Segment soll den Filter wieder löschen</p>
            </section>
        </section>


        <section id="t5">
            <h1>Teil IV</h1>
            <h2>Redux</h2>
            <a href="code/schritte/redux/6-redux/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Redux 1</h2>
            <img src="redux-01-react-cycle-no-redux.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h2>Redux 2</h2>
            <img src="redux-02-extracting-responsibility.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>
        <section>
            <h2>Redux 3</h2>
            <img src="redux-03-resulting-redux-architecture.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>

<script>
    Reveal.addEventListener( 'ready', function( event ) {
        if (window.location.hostname.indexOf('localhost') !== -1) {
            // only applies to presentation version
            Reveal.configure({ controls: false });
        } else {
            // only applies to public version
            $('.fragment').removeClass('fragment');
        }
        // applies to all versions
        $('code').addClass('line-numbers');
    } );
</script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
