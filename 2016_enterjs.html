<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>React Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!--In diesem Workshop möchten wir Ihnen zeigen, -->
    <!--wie Sie Webanwendungen mit der Open-Source-Bibliothek React entwickeln können.-->
<!--Wir werden uns dazu ansehen, wie sich einzelne, wiederverwendbare Komponenten schreiben lassen, -->
    <!--wobei auch ECMAScript-2015-Sprachfeatures zum Einsatz kommen. -->
    <!--Aus den Komponenten stellen wir dann eine ganze Anwendung zusammen und -->
    <!--implementieren mit dem React Router clientseitiges Routing. -->
    <!--Natürlich lernen Sie auch, wie sich React-Komponenten und -Anwendungen testen lassen -->
    <!--und wie ein Entwicklungsprozess (mit Webpack) für React implementiert werden kann.-->
<!--Um an dem Workshop teilzunehmen, ist ein Laptop mitzubringen, auf dem npm installiert ist.-->

<!--Vorbereitung für die Teilnehmer-->
<!-- - Bringen Sie ein Laptop mit, auf dem Sie Software installieren können-->
<!-- - npm, node v4 (https://nodejs.org/en/download/) und git müssen-->
<!--mindestens installiert sein-->
<!-- - Wir empfehlen entweder WebStorm-->
<!--(https://www.jetbrains.com/webstorm/download/, 'free 30-day trial'`-->
<!--reicht) oder Visual Studio Code-->
<!--(https://code.visualstudio.com/Download), jeweils die aktuellste-->
<!--Version-->
<!-- - Eine Woche vor der enterJs dieses Repository von github klonen:-->
<!--https://github.com/DJCordhose/react-workshop-->
<!-- - Es wird dann auf oberster Ebene eine package.json liegen-->
<!-- - Dort mit `npm install` alle Abhängigkeiten installieren-->

<!--Agenda-->
<!--ab 10 Uhr Registrierung und Begrüßungskaffee-->

<!--11 Uhr: Beginn-->

<!-- - React Grundlagen und Build-Prozess-->

<!--12:30 - 13:30 Uhr Mittagessen-->

<!-- - Komponentenhierarchien und Interaktionen-->

<!--15:00 - 15:15 Uhr Kaffeepause-->

<!-- - Testen-->
<!-- - React Router-->

<!--16:45 - 17 Uhr: kleine Kaffeepause-->

<!-- - Remote-Calls gegen Server-->

<!--ca. 18 Uhr: Ende    -->

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h3>React Workshop - Vorbereitung</h3>
            <p>Falls noch nicht gemacht:</p>
            <ol>
                <li><code>git clone -b gh-pages https://github.com/DJCordhose/react-workshop.git</code></li>
                <li>Im geklonten Verzeichnis: <code>npm install</code></li>
                <li>Im geklonten Verzeichnis: <code>npm run setup</code></li>
                <li>In <code>code/workspace</code> wechseln</li>
                <li>Ausf&uuml;hren: <code>npm run devserver</code></li>
                <li>Browser &ouml;ffnen: http://localhost:8080</li>
            </ol>
            <p>Folien: Im geklonten Verzeichnis <code>2016_enterjs.html</code>
            </p>
        </section>
        <section>
            <h1>React Workshop</h1>
            <p>
                <small><a href="http://nilshartmann.net">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann">@nilshartmann</a>
                </small>
            </p>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <p><small><a href="http://bit.ly/1UgnAH4">http://bit.ly/1UgnAH4</a></small></p>

        </section>

        <section>
            <h2>Inhalt</h2>
            <ul>
                <li><a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
                <li><a href="#/t1">Teil I: React-Komponenten und ES6 Grundlagen</a>
                <li><a href="#/t2">Teil II: Komponentenhierarchien</a>
                <li><a href="#/t3">Teil III: Testen</a>
                <li><a href="#/t4">Teil IV: React Router</a>
                <li><a href="#/t5">Teil V: Remote-Calls gegen Server</a>
            </ul>
        </section>
        <section>
            <h3>Plan</h3>
            <ul>
                <li>11:00 - 11:30: Teil 0: React-Einführung und Build-Prozess
                <li>11:30 - 12:30: Teil 1: React-Komponenten, ES6 Grundlagen
                <li><em>12:30 - 13:30: Mittagessen</em>
                <li>13:30 - 14:00: Übung für Teil 1
                <li>14:00 - 14:30: Teil 2: Komponentenhierarchien
                <li>14:30 - 15:00: Übung für Teil 2
                <li><em>15:00 - 15:15: Kaffeepause</em>
                <li>15:15 - 15:45: Teil 3: Testen (optional mit kleiner Übung)
                <li>15:45 - 16:15: Teil 4: React Router
                <li>16:15 - 16:45: Übung für Teil 4
                <li><em>16:45 - 17:00: kleine Kaffeepause</em>
                <li>17:00 - 17:30: Teil 5: Remote-Calls gegen Server
                <li>17:30 - max. 18:00: Ausblick/Fragen/Abschluss
            </ul>
        </section>

        <section id="t0">
            <h1>Teil 0</h1>
            <h2>React-Einführung und Build-Prozess</h2>
        </section>

        <section id="react">
            <h2>React</h2>
            <ul>
                <li class="fragment">Framework für Facebook und viele andere
                <li class="fragment">Komponenten kapseln Template und Logik
                  <li class="fragment">Deklarativ
                <li class="fragment">Abstraktion vom DOM: <em>f(model) -> UI</em>
                <li class="fragment">Minimales API
                <li class="fragment">Ein-Weg-Data-Binding: Zustandsänderungen stellen Komponente <b>komplett</b> neu dar
                <li class="fragment">Kann im Browser und auf dem Server rendern
                <!--<li class="fragment">wird für komplette Anwendung typischerweise mit React Router und einem Flux-Framework gekoppelt-->
                <!--<li class="fragment">viel Inspiration aus der funktionalen Ecke (Immutable, pure functions, stateless)-->
            </ul>
        </section>

        <section>
            <h3>React Komponenten</h3>
            <ul>
                <li class="fragment">Werden als ES6 Klasse oder Funktion implementiert</code>
                <li class="fragment">Keine Templatesprache (stattdessen JavaScript)</code>
                <li class="fragment">Templates können HTML-artige Syntax enthalten (JSX)
            </ul>
            <pre class="fragment"><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return &lt;h1 className='title'>Hello, World!&lt;/h1>
  }
}
</code></pre></section>

        <section>
            <h3>Hello World React</h3>
                <a target="_blank" href="code/hello_world/public/index.html">Demo</a>
        </section>

                <section>
                    <h3>Hello World React</h3>
<pre><code data-trim contenteditable>class HelloMessage extends React.Component {
  render() {
    return (&lt;div>
            &lt;input ref={input => this.input = input}
                   onChange={event => this.updateModel(event)}
                   value={this.state.greeting} />
            &lt;p>{this.state.greeting}, World&lt;/p>
            &lt;button
                onClick={() => this.reset()}>
                Clear
            &lt;/button>
        &lt;/div>);
  }</code></pre>
<pre class="fragment"><code contenteditable class="javascript">  constructor(props) {
    super(props);
    this.state = {greeting: this.props.greeting};
  }
  updateModel(event) {
    this.setState({greeting: event.target.value});
  }
  reset() {
    this.setState({greeting: ""});
    this.input.focus();
  }
}</code></pre>
                </section>
                <section>
                    <h3>Aufruf</h3>
<pre><code data-trim contenteditable>
// index.html
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
<pre class="fragment"><code data-trim contenteditable class="javascript">
// main.js
import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage greeting="Hello"/>, mountNode);
</code></pre>
                    <a target="_blank" href="code/hello_world/public/index.html">Run</a>
                </section>


    <section>
        <h2>Buildprozess</h2>
        <ul>
            <li>ES6- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <li>Typische Werkzeuge
                <ul><li>Babel (Compiler)
                    <li>Webpack (Bundler)
                    <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
                    </ul>
        </ul>
    </section>
     <section>
        <h2>Webpack und Babel</h2>
        <img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0"/>
    </section>

    </section>
    <section>
      <section>
          <h2>Übung 0: React Hello-World</h2>
          <h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
      </section>
      <section>
          <h3>Schritt #1: Tool-Chain starten</h3>
          <p>Nutze das <code>workspace</code>-Verzeichnis in diesem Repository</p>
          <p>Hier ist eine Tool-Chain mit Webpack und Babel vorbereitet</p>
          <ul>
              <li>Evtl. dafür einen Proxy konfigurieren <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a></li>
              <li><code>npm install</code> (auf oberster Ebene)
              <li><code>node setup</code> (auf oberster Ebene)
              <li><code>cd code/workspace</code>
              <li><code>npm run devserver</code>
              <li>Öffne <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
              <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
          </ul>
      </section>
      <section>
          <h3>Schritt #2: Deine erste React-Komponente</h3>
          <ul>
              <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel aus den Folien
              <li>Experimentiere mit der Anwendung, mache einige Änderungen
          </ul>
      </section>
    </section>

        <section id="t1">
            <h1>Teil I</h1>
            <h2>React-Komponenten und ES6 Grundlagen</h2>
            <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>ES6 Grundlagen
                <li>Rendering
                <li>Properties und Zustand
                <li>Refs
            </ul>
        </section>

        <section>
            <h2>ES6-Referenz</h2>
            <p><a href="http://exploringjs.com/es6/" target="_blank">
                http://exploringjs.com/es6/
            </a>
        </section>

        <section>
            <h3>JavaScript vs ECMAScript 6 vs ES6 vs ECMAScript 2015</h3>
            <ul>
                <li class="fragment">ECMAScript ist der Standard und JavaScript ist die Implementierung
                <li class="fragment">Ab IE9 sind wir bei ECMAScript 5 (2009)
                <li class="fragment">ECMAScript 2015 ist der offizielle, neue Name für ECMAScript 6
                <li class="fragment">ES6 ist der kurze Name für ECMAScript 6
                <li class="fragment">ES 2015 ist die Abkürzung für ECMAScript 2015
                <li class="fragment">ES7 wird nur 2 Details enthalten (Exp-Operator und Array.includes)
                <li class="fragment">An der Spec für ES8 wird bereits gearbeitet
            </ul>
        </section>
    <section>
        <h3>ES6: Neue Spracheigenschaften</h3>
            <h4 class="fragment"><em>keine</em> statischen Typen</h4>
            <ul>
            <li class="fragment">Template Strings
            <li class="fragment">Module
            <li class="fragment">Klassen
            <li class="fragment">Destructuring (Pattern Matching)
            <li class="fragment">let, const
            <li class="fragment">Fat arrow <b>=></b> für besseres Binding von <b>this</b>
            <li class="fragment">vararg, optional, spread operator
            <li class="fragment">Collection Types (Map, Set, WeakMap, WeakSet)
        </ul>
    </section>
                    <section>
                        <h3>ES6: Template Literals</h3>
          <p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">
         String-Literale mit Lücken
    </a>
    </p>

   <pre><code class="javascript" contenteditable>const person = 'Oma';
const language = 'Haskell';

console.log(`${person} programs
${10 * 1024 * 1024} lines of code
in ${language}.`);
// Output:
// Oma programs
// 10485760 lines of code
// in Haskell.
</code></pre>
                    </section>

        <section>
            <h3>ES6: Lexikalisches Scoping</h3>
            <pre><code class="javascript" contenteditable>{
  // no hoisting
  console.log(a);
  // => ReferenceError: a is not defined
  let a = 10;
  // or
  const a = 10;
  a = 20;
  // => TypeError: Assignment to constant variable.
}
console.log(a);
// => ReferenceError: a is not defined</code></pre>
        </section>
        <section>
            <h3>ES6: Klassen</h3>
                <pre class="fragment"><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return this.name + " codes in " + this.language;
    }
}</code></pre>
   <pre><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
         </section>

            <section>
                <h3>ES6: Arrow Functions</h3>
<pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
<pre class="fragment"><code class="javascript" contenteditable>const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
            </section>
                <!--<section>-->
                    <!--<h3>Default Parameter</h3>-->
<!--<pre><code class="javascript" contenteditable>const displayInPage = (text = '\n') =>-->
    <!--console.log(text);</code></pre>-->
<!--<pre class="fragment"><code class="javascript" contenteditable>displayInPage();-->
<!--</code></pre>-->
                <!--</section>-->
                <!--<section>-->
                    <!--<h3>Rest-Parameters</h3>-->
<!--<pre><code class="javascript" contenteditable>const displayInPage = (...texts) =>-->
    <!--texts.forEach(text => console.log(text));-->
<!--</code></pre>-->
<!--<pre class="fragment"><code class="javascript" contenteditable>displayInPage('Hi', 'Folks');-->
<!--// Hi-->
<!--// Folks-->
<!--</code></pre>-->
                <!--</section>-->

                <section>
                    <h3>ES6: Lexcial Binding an this bei Arrow-Functions</h3>
<pre><code class="javascript" contenteditable>
const obj = {
    methodOfObj: function () {
      console.log(`In Method: ${obj === this}`); // true
        ['1', '2', '3'].forEach( e => {
           console.log(`In Loop: ${obj === this}`); // true
        });
    }
};

obj.methodOfObj();
</code></pre>
            </section>

            <section>
                <h3>React: Rendering</h3>
                <ul class="fragment">
                    <li>Jede React-Komponente braucht eine <code>render</code>-Methode:</li>
                    <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
                    <li>kann HTML-artige JSX-Syntax nutzen</li>
                    <li>JSX kann pures JavaScript in geschweiften Klammern enthalten (<code>{}</code>)
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={input => this.input = input}
           onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
        </section>
           <section>
                <h3>React: Rendering #2</h3>
                <ul class="fragment">
                    <li>DOM-Events werden in React-Events verpackt
                    <li>React-Events haben weitgehend selbe API wie DOM-Events
                    <li>Es gibt keine automatische Bindung an Modelle
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={input => this.input = input}
               onChange={event => this.updateModel(event.target.value)}
               value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  updateModel(greeting) {
    this.setState({greeting});
  }
  // ...
}
</code></pre>
        </section>
        <section>
            <h3>ES6: Erweiterte Objekt-Literale</h3>
   <pre><code class="javascript" contenteditable>const name = 'Oma';
const person = {
    // ES5: name: name
    name,
    // ES5: toString: function()
    toString() {
        return this.name;
    }
};
console.log(person.name); // Oma
console.log(person.toString()); // Oma
   </code></pre>
        </section>


                    <section>
                        <h2>ES6: Module, Importe und Exporte</h2>
                    </section>
                    <section>
                        <h3>ES6: Export einer einzigen Klasse</h3>
   <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Import</h3>
   <pre><code class="javascript" contenteditable>// Programmer.js
import Person from './Person';

export default class Programmer extends Person {
  // ...
}
   </code></pre>
                    </section>
                    <section>
                        <h3>ES6: Benannte Exporte</h3>
   <pre><code class="javascript" contenteditable data-trim>// util.js
export function displayInPage(text) {
    document.body.innerHTML +=
        `${text}<br>` ;
}
// or
export { displayInPage };
   </code></pre>
   <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
displayInPage('Hello, World');
   </code></pre>
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
<!--display('Hello, World');-->
   <!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
<!--util.displayInPage('Hello, World');-->
   <!--</code></pre>-->
                    </section>
        <!--<section>-->
                        <!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
                    <!--</section>-->

                    <!--<section>-->
                      <!--<h3>Tagged Template Literals</h3>-->
          <!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
         <!--Mini-DSLs: Template-Literals mit tag-->
    <!--</a>-->
    <!--</p>-->

   <!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
  <!--console.log(strings);-->
  <!--//[ '', ' codes in ', '.' ]-->
  <!--console.log(values);-->
  <!--//[ 'Oma', 'Haskell' ]-->
  <!--return 'whatever you want';-->
<!--}-->
<!--</code></pre>-->

   <!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
<!--console.log(expanded);-->
<!--//whatever you want-->
<!--</code></pre>-->

                    <!--</section>-->

                    <section>
                        <h3>ES6: Destructuring von Objekten</h3>
   <pre><code class="javascript" contenteditable>const person = {
  name: 'Olli',
  email: 'oliver.zeigermann@gmail.com'
};</code></pre>
   <pre class="fragment"><code class="javascript" contenteditable>const {name, notThere} = person;
console.log(`name=${name}`);
// name=Olli
console.log(`notThere=${notThere}`);
// notThere=undefined
</code></pre>
   <!--<pre class="fragment"><code class="javascript" contenteditable>const {address: {city}} = person;-->
<!--console.log(`city=${city}`);-->
<!--//city=Hamburg-->
<!--</code></pre>-->
                    </section>
                    <!--<section>-->
                        <!--<h3>Destructuring bei Parametern</h3>-->
   <!--<pre><code class="javascript" contenteditable>const person = {-->
  <!--name: 'Olli',-->
  <!--address: {-->
    <!--city: 'Hamburg'-->
  <!--},-->
  <!--email: 'oliver.zeigermann@gmail.com'-->
<!--};</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--function print({email: contact}) {-->
    <!--console.log(`contact=${contact}`);-->
<!--}-->
<!--print(person);-->
<!--// contact=oliver.zeigermann@gmail.com-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--function g({name: x, y, z=10}) {-->
  <!--console.log(`x=${x}`); // x=olli-->
  <!--console.log(`y=${y}`); // y=undefined-->
  <!--console.log(`z=${z}`); // z=10-->
<!--}-->
<!--g({ name: 'olli' });-->
<!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>Destructuring bei Arrays</h3>-->
   <!--<pre><code class="javascript" contenteditable>const [a, b] = [1, 2];-->
<!--console.log(`a=${a}`);-->
<!--// a=1-->
<!--console.log(`b=${b}`);-->
<!--// b=2-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>-->
<!--const [, b] = [1, 2];-->
<!--console.log(`b=${b}`);-->
<!--//b=2-->
<!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>Erweiterte Objekt-Literale</h3>-->
   <!--<pre><code class="javascript" contenteditable>const name = 'Oma';-->
<!--const person = {-->
    <!--// ES5: name: name-->
    <!--name,-->
    <!--// ES5: toString: function()-->
    <!--toString() {-->
        <!--return this.name;-->
    <!--}-->
<!--};-->
<!--console.log(person.name); // Oma-->
<!--console.log(person.toString()); // Oma-->
   <!--</code></pre>-->
                    <!--</section>-->
                    <!--<section>-->
                        <!--<h3>for..of</h3>-->
          <!--<p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">-->
         <!--Iterieren über alles was 'iterable' ist-->
    <!--</a>-->
    <!--</p>-->

   <!--<pre><code class="javascript" contenteditable>for (const e of array2) {-->
    <!--console.log(e);-->
<!--}-->
<!--// Hi-->
<!--// Olli-->
<!--// how are you-->
<!--// ?-->
<!--</code></pre>-->
                    <!--</section>-->

    <!--<section>-->
                        <!--<h3>Spread-Operator</h3>-->
          <!--<p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">-->
          <!--Alles was 'iterable' ist kann in einzelne Parameter transformiert werden-->
    <!--</a>-->
    <!--</p>-->
   <!--<pre><code class="javascript" contenteditable>const array1 = ['Olli', 'how are you'];-->
<!--const array2 = ['Hi', ...array1, '?'];-->
<!--console.log(array2);-->
<!--// => ["Hi", "Olli", "how are you", "?"]-->
<!--</code></pre>-->
   <!--<pre class="fragment"><code class="javascript" contenteditable>console.log(...array1);-->
<!--</code></pre>-->
                    <!--</section>-->

                <!--<section>-->
                    <!--<h2>Verbesserungen bei Funktionen in ES6</h2>-->
                <!--</section>-->


        <section>
            <h3>React: Properties und Zustand</h3>
            <ul class="fragment">
                <li><b>Properties</b> werden der Komponente von <b>außen</b> übergeben (und nicht verändert)</li>
                <li><b>Zustand (State)</b> ist eine <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
                <li>Beides sind Objekte mit Key-Value-Paaren</li>
                <li>Beide können an Unterkomponenten übergeben werden</li>
            </ul>
        </section>

        <section>
            <h3>Properties einer Komponente</h3>
            <ul class="fragment">
                <li>Properties werden von außen über den Konstruktor übergeben</li>
                <li>Properties dürfen nicht verändert werden</li>
                <li>Zugriff über <code>this.props</code></li>
            </ul>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
class TitleComponent extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
      return &lt;h1>{this.props.title}&lt;/h1>
    }
   // ...
}
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
  &lt;TitleComponent title='Hello World' />
</pre></code>

        </section>

        <section>
            <h3>Zustand einer Komponente</h3>
            <ul class="fragment">
                <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server</li>
                <li>Werte üblicherweise immutable</li>
                <li>Initialisieren im Konstruktor mit <code>this.state={}</code>
                <li>Zustand <b>lesen</b> über <code>this.state</code>
                <li>Zustand <b>setzen</b> über <code>this.setState()</code>
                <ul><li>kein "reiner" Setter</li>
                    <li>Führt alten und neuen Zustand zusammen</li>
                    <li><b>Löst erneutes rendern der <i>gesamten</i> Komponente aus</b></li>
                </ul>
            </ul>
            </section>

            <section>
                <h3>Beispiel: Zustand einer Komponente</h3>
<pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
        </section>
        <section>
            <h3>Render Zyklus</h3>
            <img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Virtual DOM</h3>
            <img src="images/virtual-dom.png" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>React: Refs</h3>
            <ul class="fragment">
                <li>Beim rendern kann man an eine Referenz des unterliegenden DOMs kommen
                <li>die DOM-Referenz kann einer Funktion übergeben werden
                <li>Diese Referenz kann man z.B. als Member-Variable speichern
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
    render() {
        return (
            <div>
                &lt;input ref={input => this.input = input} />
                &lt;button
                    onClick={() => this.input.focus()}>
                    Focus
                &lt;/button>
            </div>);
    }
}
</code></pre>
        </section>

        <section>
      <section>
          <h2>Übung 1: Detail-Ansicht für unsere Gruß-Anwendung</h2>
          <h3>Erzeuge eine Komponenten mit der man einen Namen und eine Grußformel eingeben kann</h3>
      </section>
      <section>
          <h3>Schritte</h3>
          <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
          <ul>
              <li>benenne deine Komponente in <code>GreetingDetail</code> um
              <li>du brauchst zwei Eingabefelder, die <code>name</code> und <code>greeting</code> im Zustand der Komponente setzen
              <li>für etwas Styling kopiere das Material in <code>code/material/1-detail</code> in deinen <code>public</code>-Ordner
              <li><em>Zusatzaufgabe: Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand initialisieren</em>
          </ul>
      </section>
    </section>


        <section id="t2">
            <h1>Teil II</h1>
            <h2>Komponentenhierarchien</h2>
            <h3>Komplette Anwendung aus Komponenten bauen</h3>
            <a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Referenz</h2>
            <p><a href="https://facebook.github.io/react/docs" target="_blank">
                https://facebook.github.io/react/docs
            </a>
            </p>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li>Komponenten als Funktion
                <li>Darstellung von Listen und Keys
                <li>Architektur-Idee: Controller-Komponente und View-Komponente
                <li>Durchreichen von Zustand und Callbacks
                <li>PropTypes
            </ul>
        </section>

            <section>
                <h3>Komponenten als Funktion</h3>
                <ul class="fragment">
                    <li>Komponente ist eine einfache Funktion</li>
                    <li>entspricht der <code>render</code>-Methode</li>
                    <li>Properties werden als Parameter übergeben</li>
                    <li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
function Layout(props) {
  return (
      <div className="Main">
        <div className="Container">
          {props.children}
        </div>
      </div>
  );
}
</code></pre>
        </section>

            <section>
                <h3>Listen und Keys</h3>
                <ul class="fragment">
                    <li>JSX bietet nichts für Listen
                    <li>Ausgabe typischerweise über <code>Array.map</code>
                    <li>Elemente einer Liste brauchen einen eindeutigen key
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [{
    id: 0,
    name: 'Olli',
    greeting: 'Huhu'
},
{
    id: 1,
    name: 'Oma',
    greeting: 'Hallo'
}
];
const body = greetings.map(greeting =>
    &lt;tr key={greeting.id}>
        &lt;td>{greeting.name}</td>
        &lt;td>{greeting.greeting}</td>
    &lt;/tr>);
</code></pre>
        </section>

        <section>
            <h3>Controller und Child-Views</h3>
            <img src="images/controller.png" height="600" style="border:0;box-shadow:0 0 0 0">
        </section>

        <section>
            <h3>Durchreichen vom Zustand und Callbacks</h3>
            <ul class="fragment">
                <li>Funktioniert beides über Properties
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
    render() {
        const {greetings} = this.state;
        return (
            <div>
                &lt;GreetingMaster greetings={greetings}
                    onAdd={() => this.setState({mode: MODE_DETAIL})}
            </div>);
    }
    // ...
}
    </code></pre>
    </section>
    <section>
        <h3>Properties übergeben mit Object-Spread</h3>
        <ul class="fragment">
                <li>Übergibt <b>alle</b> Eigenschaften eines Objektes als individuelle Properties</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {

    const greeting = { name: 'Klaus', greeting: 'Hello' };

    render() {
        return &lt;GreetingDetail {...greeting} />

        // entspricht:
        // &lt;GreetingDetail name='Klaus' greeting='Hello' />
    }
}
        </code></pre>
    </section>

        <section>
            <h3>PropTypes</h3>
                <ul class="fragment">
                    <li>Eine Komponente kann deklarieren, welche Properties sie erwartet
                    <li>Auch der Typ kann angegeben werden
                    <li>Fehlende / falsche Properties führen zu Laufzeitfehlern
                    <li><a href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation " target="_blank">Mögliche Typen</a>
                </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
GreetingDetail.propTypes = {
    greeting: PropTypes.shape({
      name: React.PropTypes.string.isRequired,
      greeting: React.PropTypes.string.isRequired
    }),
    onAdd: PropTypes.func.isRequired
};
</code></pre>
        </section>

        <section>
            <section>
                <h2>Übung 2: Eine komplette Anwendung zusammen setzen</h2>
                <h3>Füge deinen Detail-View und einen Master-View über eine Controller-Komponente zusammen</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/2-hierarchy</code> in deinen src-Ordner
                    <li>erweitere im <code>GreetingController</code> die render-Methode, so dass dein Detail-View ebenfalls angezeigt wird, wenn der Benutzer den Add-Button klickt
                    <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
                    <li>übergib einen Callback der <code>addGreeting</code> nutzt
                    <li>im deinem <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
                </ul>
            </section>
            <section>
                <h3>Architektur Beispiel-Anwendung</h3>
                <img src="ai/greeting-hierarchy.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingMaster</h3>
                <img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
            <section>
                <h3>GreetingDetail</h3>
                <img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0"/>
            </section>
        </section>

        <section id="t3">
            <h1>Teil III</h1>
            <h2>Testen</h2>
        </section>

        <section>
            <h2>Was testen wir überhaupt?</h2>
            <ul>
                <li class="fragment"><b>UI-unabhängige Logik</b> (React-unabhängig)</li>
                <li class="fragment"><b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)</li>
                <li class="fragment"><b>Interaktionen</b> (Funktionieren meine Event-Listener korrekt)</li>
                <li class="fragment"><b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit history, Titelzeile, Scrollbars etc)</li>
                </ul>
        </section>

        <section>
            <h2>React Test Utils</h2>
            <ul>
                <li>Doku: <a href="https://facebook.github.io/react/docs/test-utils.html">https://facebook.github.io/react/docs/test-utils.html</a></li>
                <li>Eigenes npm Modul (<code>react-addons-test-utils</code>)</li>
                <li>Verwendung mit jeder beliebigen Assertion-Bibliothek und Test-Runner</li>
                <li>Hilfsfunktionen zum Suchen von Elementen und Komponenten im DOM</li>
                <li>Shallow Renderer</li>
            </ul>
            </section>

        <section>
            <h2>Variante 1: Shallow Rendering</h2>
            <ul>
                <li>Rendert <b>virtuellen DOM</b> (kein nativer DOM benötigt)</li>
                <li>Ein Knoten im virtuellen DOM besteht u.a. aus:
                    <ul><li><code>type</code> (z.B. <code>div</code>)</li><li>props</code></li></ul>
                </li>
                <li>Über den virtuellen DOM kann man Properties abfragen und Callbacks aufrufen
                <li>Rendert nur <b>eine</b> Hierarchieebene (shallow)
            </ul>
            </section>
        <section>
            <h2>ReactElement</h2>

            <div class="fragment">
            <p>Komponente</p>
            <img src="images/react-element.png" style="border:0;box-shadow:0 0 0 0"/>
            </div>
            <div class="fragment">
                <p style="margin-top:0px">natives HTML Element</p>
                <img src="images/react-element-2.png" style="border:0;box-shadow:0 0 0 0"/>
            </div>
        </section>

        <section>
            <h2>ReactElement</h2>
            <p>Children</p>
            <img class="fragment" src="images/react-element-3.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h2>Beispiel: Shallow Rendering</h2>
            <pre><code class="javascript" contenteditable data-trim>
import ReactTestUtils from 'react-addons-test-utils';

const renderer = ReactTestUtils.createRenderer();

renderer.render(
    &lt;GreetingMaster greetings={sampleGreetings} /&gt;
);

const tree = renderer.getRenderOutput();
// tree enthält virtuellen DOM
        </pre>
        </code>
        </section>
        <section>
            <h2>Shallow Rendering: Assertions</h2>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
. . .
const tree = renderer.getRenderOutput();
</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
expect(tree.type).toBe('div');
expect(tree.props.children.length).toEqual(2); // table ~ button

const table = tree.props.children[0];
expect(table.type).toBe('table');

const tbody = table.props.children[1];
expect(tbody.type).toBe('tbody');
</code></pre>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
const rows = tbody.props.children;
expect(rows).toEqual([
    &lt;tr key='1'&gt;&lt;td&gt;Olli&lt;/td&gt;&lt;td&gt;Huhu&lt;/td&gt;&lt;/tr&gt;,
    &lt;tr key='2'&gt;&lt;td&gt;Oma&lt;/td&gt;&lt;td&gt;Hallo&lt;/td&gt;&lt;/tr&gt;
]);
</code></pre>
            </section>

                    <section>
            <h2>Shallow Rendering: Callbacks aufrufen</h2>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Ausgangssituation
const nameInput = tree.props.children;
expect(nameInput.props.value).toEqual('Lemmy');
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const changeEvent = { target: { value: 'Klaus-Dieter' } };
nameInput.props.onChange(changeEvent);
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
const updatedTree = renderer.getRenderOutput();

const updatedNameInput = updatedTree.props.children;
expect(updatedNameInput.props.value).toEqual('Klaus-Dieter');
        </code></pre>
            </section>


        <section>
            <h2>Variante 2: Rendering ins DOM</h2>
            <ul>
                <li>benötigt natives DOM</li>
                <li>DOM kann aus JSDOM kommen oder aus echtem Browser
                <li>Rendert einen kompletten Baum
                <li>Einfacher für Interaktionen, da nur Clicks ausgelöst werden müssen
            </ul>
            </section>

        <section>
            <h2>Beispiel: Rendering ins DOM</h2>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
const component = ReactTestUtils.renderIntoDocument(
    &lt;GreetingDetail greeting={greeting} />
);
        </pre>
        </code>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
const [nameInput, greetingInput] =
  ReactTestUtils.scryRenderedDOMComponentsWithTag(component, 'input');
const [clearButton, saveButton] =
  ReactTestUtils.scryRenderedDOMComponentsWithTag(component, 'button');
        </pre>
        </code>
            <pre class="fragment"><code class="javascript" contenteditable data-trim>
ReactTestUtils.Simulate.click(clearButton);
expect(nameInput.value).toEqual('');
expect(clearButton.value).toEqual('');
        </pre>
        </code>
        </section>

        <section>
            <h2>Testen</h2>
            <ul>
            <li>React-Anwendungen sind sehr gut testbar, auch ohne Browser
            <li>Ausblick/Alternativen:
                <a href="https://github.com/airbnb/enzyme" target="_blank">
                airbnb enzyme</a>,
                <a href="https://github.com/bruderstein/unexpected-react" target="_blank">unexpected react</a></li>
            </ul>
            </section>

            <section>
                <section>
                    <h2>Übung 3: Eine React-Komponente testen</h2>
                    <h3>Stelle sicher, dass in der Komponente GreetingDetail das Klicken des Save-Buttons funktioniert:</h3>
                    <ol>
                        <li>Der übergebene Event-Handler sollte aufgerufen werden</li>
                        <li>Dem Event-Handler muss mit einem Objekt aufgerufen werden, das dem eingegebenen Greeting entspricht</li>
                    </ol>
                </section>
                <section>
                    <h3>Schritte</h3>
                    <ul>
                        <li>kopiere das Material aus <code>code/material/3-test</code> in deinen <code>src</code>-Ordner</li>
                        <li>Verwende die React Test Utils um die <code>GreetingDetail</code>-Komponente zu rendern
                        <li>Suche im gerenderten DOM den <code>Save</code> Button
                        <li>"Klicke" den Save Button</li>
                        <li>Stelle sicher, dass die übergebene <code>onAdd</code>-Callback Funktion aufgerufen wurde</li>
                        <li>Test kann mit <code>npm run test:watch</code> ausgeführt werden (reagiert auf Code-Änderungen)</ul>
                </section>

            </section>




        <!--Master View wäre gutes Beispiel für shallow rendering-->

        <!--Identisches Beispiele für shallow rendering und jsdom rendering zeigen-->

        <!--Macht eine Übung überhaupt Sinn? Wenn ja, was machen?-->

        <section id="t4">
            <h1>Teil IV</h1>
            <h2>React Router</h2>
            <a href="code/schritte/4-router/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>API-Reference</h2>
            <p><a href="https://github.com/reactjs/react-router/blob/master/docs/API.md" target="_blank">
                https://github.com/reactjs/react-router/blob/master/docs/API.md
            </a>
            </p>
        </section>

        <section>
            <h3>Themen</h3>
            <ul>
                <li><code>Route</code> und <code>IndexRoute</code>
                <li>history
                <li>Nested routes und das <code>children</code>-Property
                <li>Links
                <li><code>location</code> und <code>param</code> Property und <code>componentWillReceiveProps</code>
            </ul>
        </section>

        <section>
            <h3>Router, Route, IndexRoute, Redirect</h3>
<pre class="fragment"><code class="xml" contenteditable data-trim>
import { Router, Route, Redirect, IndexRoute, hashHistory }
    from 'react-router';

const routes = &lt;Router history={hashHistory}>
  &lt;Redirect from="/vote" to="/votes"/>
  &lt;Route path="/" component={Layout}>
    &lt;IndexRoute component={VotePage}/>
    &lt;Route path="votes/:id" component={SingleVotePage}/>
    &lt;Route path="login(/:redirect)" component={LoginPage}/>
    &lt;Route path="compose" component={VoteComposerPage} onEnter={requireAuth}/>
    &lt;Route path="*" component={NoMatchPage}/>
  &lt;/Route>
&lt;/Router>;
</code></pre>
        </section>

        <section>
            <h3>Router</h3>
            <ul class="fragment">
                <li>Echte React-Komponente</li>
                <li>Top-Level-Komponente, entscheidet anhand der <b>history</b>, was dargestellt wird</li>
                <li>hat Routen als Kinder</li>
            </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
const routes = &lt;Router history={hashHistory}>
...
&lt;/Router>;
</code></pre>
        </section>

        <section>
            <h3>History</h3>
            <ul class="fragment">
                <li>kommt aus dem <a target="_blank" href="https://github.com/mjackson/history">history</a>-Projekt</li>
                <li>Abstraktion der History des Browsers</li>
                <li>kann zur Navigation genutzt werden</li>
                <li>liefert aktuelle URL mundgerecht an den Router</li>
                <li><code>hashHistory</code> codiert Pfad in angehängten Hash (#/vote)
                <li><code>browserHistory</code> codiert Pfad direkt in URL (/vote)
            </ul>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
// Push a new entry onto the history stack.
history.push('/home')

// Replace the current entry on the history stack.
history.replace('/profile')
</code></pre>
        </section>

        <section>
            <h3>Route</h3>
            <ul class="fragment">
                <li>Konfigurations-Komponente</li>
                <li>welche Komponente soll bei welcher URL darstellt werden</li>
                <li>können verschachtelt werden (nested)</li>
                <li>Matching der URL mit Konfiguration ergibt einen Pfad</li>
                <li>Alle Komponenten des Pfads werden dargestellt</li>
            </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
// plain match (containing nested routes)
&lt;Route path="/" component={Layout}>
    // id is passed as parameter to component
    &lt;Route path="votes/:id" component={SingleVotePage}/> /
    // redirect is optional
    &lt;Route path="login(/:redirect)" component={LoginPage}/>
    // onEnter and onExit possible as hooks
    &lt;Route path="compose" component={VoteComposerPage}
        onEnter={requireAuth}/>
    // wildcard
    &lt;Route path="*" component={NoMatchPage}/>
&lt;/Route>
</code></pre>
        </section>

        <section>
            <h3>IndexRoute und Redirect</h3>
<pre class="fragment"><code class="xml" contenteditable data-trim>
  // /vote redirects to /votes
&lt;Redirect from="/vote" to="/votes"/>
&lt;Route path="/" component={Layout}>
  // will be rendered additionally when path is just /
  &lt;IndexRoute component={VotePage}/>
  // ...
&lt;/Route>
</code></pre>
        </section>

        <section>
            <h3>Nested Routes und children</h3>
            <ul class="fragment">
                <li>Router rendert den gematchten Komponenten-Pfad als seine Unterkomponenten
                <li>Unterkomponenten werden als <code>children</code> in den <code>props</code> übergeben
                <li><code>children</code> kann grundsätzlich eine oder mehrere Komponenten sein
                <li>beim Router ist es immer nur eine Komponente
            </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
export default function Layout(props) {
    return <div>
        <h1>Greetings</h1>
        {props.children}
    </div>;
}
</code></pre>
        </section>

            <section>
                <h3>Link</h3>
                <ul class="fragment">
                    <li>Echte React-Komponente</li>
                    <li>Ein Link auf eine Route</li>
                    <li>wird als <code>a</code>-Element gerendert</li>
                    <li>hat zudem einen Click-Handler, der den Default verhindert und das history-Objekt updated</li>
                    <li>weiß, ob die Route auf die sie verweist, aktiv ist</li>
                </ul>
<pre class="fragment"><code class="xml" contenteditable data-trim>
&lt;Link to={`/votes/${vote.id}`} activeClassName='active'>
  <h1 className="Title">{vote.title}</h1>
&lt;/Link>
</code></pre>
        </section>

        <section>
            <h3>Datenübergabe an Routen</h3>
            <p>Der Router übergibt den zu rendernden Routen Daten als Properties</p>
            <ul class="fragment">
                <li>Property <code>location</code>: enthält <code>pathname</code> und <code>query</code></li>
                <li>Property <code>params</code>: die dynamischen Segmente der Route (z.B. <code>id</code>)</li>
                <li>Lifecycle-Methode <code>componentWillReceiveProps</code>: wird mit neuen Properties aufgerufen, wenn sich die Route geändert hat
            </ul>
        </section>

        <section>
            <section>
                <h2>Übung 4: Die Anwendung und Admin- und Nutzer-Ansicht unterteilen</h2>
                <h3>Erstelle eine Route für den bestehenden Admin-Teil und binde eine Nutzer-Ansicht ein, die den Gruß darstellt</h3>
            </section>
            <section>
                <h3>Schritte</h3>
                <ul>
                    <li>kopiere das Material aus <code>code/material/4-router</code> in deinen src-Ordner
                    <li><code>GreetingMaster</code> enthält Links auf darzustellende Grüße
                    <li>füge in <code>main.js</code> eine Route auf <code>GreetingDisplay</code> hinzu
                    <li>fülle <code>GreetingDisplay</code> so dass sie einen solchen Gruß darstellt mit den vom Router übergebenen Parametern ausgibt
                </ul>
            </section>
        </section>

        <section id="t5">
            <h1>Teil V</h1>
            <h2>Remote-Calls gegen Server</h2>
            <a href="code/schritte/5-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <section>
                <h2>Übung 5: Laden und Speichern der Daten von/auf einem Server</h2>
                <h3>Entwickelt gemeinsam mit den Workshop-Leitern eine Version, die die Grüße über eine id darstellen kann</h3>
            </section>

            <!--Idee: gemeinsam Live entwickeln und dabei die Punkte herausarbeiten-->
            <!-- - wie macht man das laden und speichern technisch: fetch vorgeben-->
            <!-- - wie funktioniert asynchrones?-->
            <!-- - wo lädt man die Daten eigentlich: live cycle methoden-->
            <!-- - was macht man mit der id?-->
            <section>
                <h3>Herausforderungen</h3>
                <ul>
                    <li>Wo speichern wir?
                    <li>Wie machen wir das Laden und Speichern technisch?
                    <li>Wie funktioniert asynchrone Verarbeitung in React?
                    <li>Wo steht der Code zum Laden der Grüße?
                </ul>
            </section>

            <section>
                <h3>Material: Firebase</h3>
                <ul>
                    <li><code>https://gruss.firebaseio.com/</code>: Admin-Interface der Firebase DB
                    <li><code>curl 'https://gruss.firebaseio.com/rest/greetings.json'</code> greetings holen
                    <li><code>curl -X PUT -d '[{ "id": 1, "name": "Oma", "greeting": "Hiho"}, {"id": 2, "name": "Opa"}]' 'https://gruss.firebaseio.com/rest/greetings.json'</code> greetings speichern
                    <li><code>curl 'https://gruss.firebaseio.com/rest/greetings.json?orderBy="id"&equalTo=3'</code> greeting über id laden
                </ul>
            </section>
            <section>
                <h3>Material: fetch</h3>
<pre><code class="javascript" contenteditable data-trim>
fetch(url, {
    method: 'PUT',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
})
.then(response => response.json())
.then(json => /* ... */)
.catch(ex => console.error('request failed', ex));
</code></pre>
            </section>
        </section>


        <!--<section>-->
            <!--<h2>Optionale Übung: Remote Calls</h2>-->
            <!--<h3>Lade und Speichere Grüße vom/auf dem Server</h3>-->
        <!--</section>-->

        <section>
            <h2>Optional: Promises</h2>
        </section>
                <section>
                        <h3>fetch</h3>
<pre><code class="javascript" contenteditable>const url = `${BACKEND_URL}${path}`;

return fetch(url)
    .then(response => response.json())
    .then(json => /* ... */)
    .catch(ex => console.error('request failed', ex));
</code></pre>
                </section>
                    <section>
                        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
                        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
                    </section>

                <section>
                        <h3>Erzeugen und asynchron reagieren</h3>
   <pre class="fragment"><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre><code class="javascript" contenteditable>promise.then(value => console.log(value));
// Output after 1 second: Result from promise
</code></pre>
                    </section>
                    <section>
                        <h3>Verkettete Ausführung</h3>
   <pre><code class="javascript" contenteditable>const promise = new Promise(resolve =>
    setTimeout(
        () => resolve('Result from promise'),
        1000)
);
</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
    <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
                    </section>
            <section>
                <h3>Fehler führen zum Abbruch der Chain</h3>
                <h4 class="fragment">Allerdings muss man etwas tun, um das mitzubekommen</h4>
            </section>

                    <section>
                        <h3>Catch-Klausel</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
                    </section>
                    <section>
                        <h3>Catch-Klausel im Fehlerfall</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
                    </section>
                    <section>
                        <h3>Catch-Klausel bei Ablehnung</h3>
   <pre><code class="javascript" contenteditable>Promise
    // creates and directly rejects promise
    .reject('Promise rejected')
    .then(x => {
        // this will NOT be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// error:  Promise rejected</code></pre>
                </section>

    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
