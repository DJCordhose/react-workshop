<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Frontend Architecture</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
        .reveal pre code {
            max-height: 1000px !important;
        }
        img {
            border: 0 !important;
            box-shadow:0 0 0 0 !important;
        }

        .reveal {
            -ms-touch-action: auto !important;
            touch-action: auto !important;
        }

    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

<!--ALWAYS finish your talk on a slide that's easily photographed and tells people where to get more info. Leave it up while you take Qs-->
<!--https://twitter.com/hadleywickham/status/888367562190409728?s=03-->

<!--https://2017.javazone.no/program/5ddf7fcd3cdd41d78091f0677eb4eec0-->

<!--
        60 Minutes

        React, Angular 2, and lately also Vue govern the realm of modern frontend frameworks.
        Largely independent of which framework you choose there is a variety of architectural
        approaches you can use. The challenges you face in frontend architecture are very different from
        backend architectures in that the control and data flow rather goes in cycles than traversing through layers.
        Additionally, decoupling of parts of the application must not impact the user experience,
        so that the user has the impression of one consistent and coherent system.
        These challenges are often underestimated and most attention goes to the backend.

        We will shed some light into the matter and talk about MVC, Transparent Reactive Programming, State Management, Reactive Streams. We will also cover the main architectural challenges including

        * where to maintain state
        * how to change relevant parts of the UI when state changes
        * how to structure your application when it grows
        * there is no ideal solution, but you can still choose which compromise you are willing to take


        If you are not interested in JavaScript or the browser,
        this session can still be interesting as all these patterns are applicable to any other
        language and any other runtime environment.
-->

<!--Das hier auf Englisch-->

<!--Based on:-->
<!--* 2017_herbstcampus.html-->

        <section data-markdown class="preparation">
            <script type="text/template">
### Preparation

Komplex SPA

- cd ~/Development/js/react-workshop
- npm install
- npm start
- cd code/schritte/redux/redux-complete-app-typescript
- npm start
- Checken, dass localhost:8080 im Browser läuft

Universal

- cd code/universal
- npm install
- npm start
- Checken, dass localhost:3000 im Browser läuft
            </script>
        </section>

        <section>
            <h2>Overview of current (JavaScript) frontend architectures</h2>
            <h3><a href="https://2017.javazone.no/program/5ddf7fcd3cdd41d78091f0677eb4eec0" target="_blank">
                JavaZone, Oslo 2017</a></h3>
            <p>
                <a href="http://nilshartmann.net">Nils Hartmann</a> / <a href="http://twitter.com/nilshartmann">@nilshartmann</a>
            </p>
            <p>
                <a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
            </p>

            <p><small>Slides: <a href="http://djcordhose.github.io/react-workshop/2017_javazone.html">
                http://djcordhose.github.io/react-workshop/2017_javazone.html</a></small></p>
        </section>

        <section>
            <img src="internet-is-for-end-users.png">

            <p><small><a href="https://twitter.com/igrigorik" target="_blank">
                @igrigorik
            </a>: <a href="https://twitter.com/igrigorik/status/891901115045785600" target="_blank">
                https://twitter.com/igrigorik/status/891901115045785600
            </a></small></p>
        </section>

        <section>
            <h2>Grundproblem bei einer komplexen Web-Anwendung</h2>
            <h3>Beste UI/UX beißt sich mit Anforderungen an Wartbarkeit</h3>
        </section>

        <section>
            <h2>Was macht Frontend-Architektur schwierig?</h2>
            <h3 class="fragment">Das "Problem" ist der <em>Benutzer!</em></h3>

            <ul>
                <li class="fragment">alles soll wirken wie aus einem Guss
                    <ul>
                        <li>einheitliches Layout (UI)
                        <li>einheitliches Bedienkonzept (UX)
                    </ul>
                </li>
                <li class="fragment">reaktionsschnelles UI, auch unter Last
                <li class="fragment">Anzeige soll jederzeit über alle Komponenten konsistent sein
                <li class="fragment">alles von Anfang an da, ohne Verzögerung
            </ul>
            <!--<p class="fragment"><small>Oder man nimmt auf den Benutzer keine Rücksicht wenn es das Geschäftsmodell zulässt</small></p>-->
        </section>

        <section>
            <h2>Wo ist das Problem? Das ist doch einfach oder?</h2>
            <h3 class="fragment">Prominente Gegenbeispiele</h3>
            <ul>
                <li class="fragment">Facebook, LinkedIn, Twitter: Alle kämpfen mit uneinheitlichem Anzeigestand
                <!--Add screenshot from LinkedIn-->
                <li class="fragment">Gmail: Ladebalken am Anfang, langsamere erste Page Impression
                <li class="fragment">Amazon: uneinheitliches Layout und Bedienkonzept
                <li class="fragment">Viele seiten von Behörden/Ämtern/Großkonzernen etc.: zähes UI, validieren der Eingaben erst nach Submit
            </ul>
        </section>

        <section>
            <h2>Sind die alle unfähig?</h2>
            <p class="fragment">Oder liegt das eher an Konflikten mit anderen typischen Anforderungen?</p>
            <p class="fragment">Natürlich soll das alles auch</p>
            <ul>
                <li class="fragment">schnell und kostengünstig entwickelt werden
                <li class="fragment">über Jahrzehnte wartbar sein
                <li class="fragment">als Komponenten oder Teilprojekte entwickelbar sein
                <li class="fragment">eine einheitliche Architektur haben
                <li class="fragment">zum Skillset der vorhandenen Entwickler passen
            </ul>
        </section>

        <!--<section>-->
            <!--<h2>Typische Szenarien</h2>-->
            <!--<p>Das gucken wir uns heute an</p>-->
            <!--<ul>-->
                <!--<li class="fragment"><strong>Was alle wissen wollen</strong>: Microservices im Backend (Monolithischer Client vs Vertikalen)-->
                <!--<li class="fragment"><strong>Das Geheimnis der Single-Page Apps</strong>: Komplexes Zusammenspiel von Komponenten (State Management, Wartbarkeit)-->
                <!--<li class="fragment"><strong>Quadratur des Kreises</strong>: Schnelle erste Anzeige bei gleichzeitig hoher Interaktivität (Universal Rendering)-->
                <!--<li class="fragment"><strong>Uncool, aber häufig Hauptbestandteil der Anwendung</strong>: Effiziente, aber funktionale Formulare (Redux-Form)-->
            <!--</ul>-->
        <!--</section>-->

        <section>
            <h3>Klassiche Webanwendung</h3>
            <p><small>jeder Boot tut gut, jeder Roundtrip setzt Zustand zurück</small></p>

            <img src="embarc/KlassischeWebAnwendung.png" style="height: 450px;">
            <p><small>Copyright 2016, embarc</small></p>
        </section>

        <section>
            <h2>Klassichen Webanwendungen</h2>
            <ul class="fragment">
                <li>Browser sendet HTTP-Request und empfängt HTML
                <li>Content wird auf der Server-Seite gerendert
                <li>Jede Interaktion wiederholt diesen Zyklus
            </ul>
        </section>

        <section>
            <h2>Klassische Webanwendung: Oft ein nahe liegender Ansatz</h2>
            <ul class="fragment">
                <li>Klassische Webanwendung sind für viele Enterprise-Entwicklungen der natürliche Ausgangspunkt
                <li>Server-Seitige Entwicklung mit Java/C# und HTTP und HTML sind gut verstanden
                <li>kleinere UI-Änderungen können auf Client-Seite mit JavaScript-Schnippseln (jQuery) realisiert werden
                <li>häufig ist dies völlig ausreichend
            </ul>
        </section>

        <section>
            <h2>Grenzen</h2>
            <ul class="fragment">
                <li>UI/UX ist grunsätzlich eingeschränkt
                <li>selbst in vermeintlich klassischen Anwendungen verstecken sich SPAs oft als Teile
                <li>z.B. JSF Komponenten mit einem komplexen UI
                <li>Vermischung von client- und serverseitigem Rendering macht Anwendungsarchitektur und Programmiermodell abenteuerlich
            </ul>
            <p class="fragment"><em>Perfide, da zuerst die Aufwände zur Umsetzung ansteigen und der Code immer unübersichtlicher wird.</em></p>
        </section>

        <section>
            <h2>Was geht nicht mehr? Ein Beispiel</h2>
                <div>
                    <a href="http://localhost:8080/" target="_blank">
                        <img src="greeting-app-complex.png" style="height: 500px;">
                    </a>
                </div>
            <p><small>Gar nicht mal so komplex...</small></p>
        </section>

        <section>
            <h3>Nächster Schritt</h3>
            <h2>Single-Page Application</h2>
        </section>

        <section>
            <h3>Überblick: Single-Page Application</h3>
            <img src="embarc/SP-Anwendung.png" style="height: 500px;">
            <p><small>Copyright 2016, embarc</small></p>
        </section>
        <section>
            <h3>Single-Page Applications (SPAs) verschieben eure Anwendung in den Browser</h3>
            <ul class="fragment">
                <li>eine einzige Seite pro Anwendung/Modul
                <li>läuft ohne signifikanten Server-Anteil
                <li>kann auch als statische Web-Seite laufen
                <li>ermöglicht Offline-Betrieb
                <li>Bedienbarkeit wie Desktop
                <li>Browser bietet mächtige Speicherungsmöglichkeiten
            </ul>
        </section>

        <section>
            <h3>Komponenten basierte Ansätze mit Templates</h3>
            <ul class="fragment">
                <li>Templates nun auf der Clientseite
                <li>Anwendung bekommt Struktur
                <li>Logik hängt an Komponenten, ist keine lose Schnippsel-Sammlung wie bei jQuery
            </ul>
            <p class="fragment">Findet sich wieder in React, Angular und Vue</p>
        </section>

        <section>
            <h1>Smart and Dumb Components</h1>
            <h2>Klares Architektur Pattern</h2>
        </section>

        <section>
            <h3>Smart Components</h3>
            <ul>
                <li>Verwalten Teilzustand der Anwendung
                <li>Reichen Teile des Zustands als unveränderliche Daten an Unterkomponente weiter
                <li>Enthalten UI Logik, die sie als Callbacks an ihre Unterkomponenten weiter geben können
                <li>Meist spezifisch für eine Domäne
                <li>Nicht außerhalb der Domäne wiederverwendbar
            </ul>
        </section>

        <section>
            <h3>Dumb Components</h3>
            <ul>
                <li>Managen höchstens transienten State
                <li>enthalten keine Logik
                <li>Unterkomponente sind meist selbst nur Dumb Components (es gibt
                    <a target="_blank" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.z8xy5zvhs">
                        Ausnahmen</a>)
                <li>haben kein Wissen oder Abhängigkeit zu Oberkomponenten
                <li>wievervwendbar
            </ul>
        </section>

        <section>
            <img src="smart-dumb-properties.png">
        </section>

        <section>
            <h2>Code Sample Angular</h2>
            <p>Using rxjs for communication between Smart and Dumb Component</p>
            <p class="todo">Short Intro rxjs</p>
        </section>

        <section>
            <h2>Smart Component</h2>
            <pre><code data-trim>
@Component({
  template: `<sub greeting={{greeting}} (onSend)="sent($event)"></sub>`
})
export class AppComponent {
  private greeting: string = 'Hiho';

  constructor(private greetingService: GreetingService) {
  }

  // "Business Logic" delegated to service
  sent(greeting) {
    this.greeting = this.greetingService.greetBack(greeting);
  }
}
            </code></pre>
        </section>

        <section>
            <h2>Dumb Component</h2>
            <pre><code data-trim>
@Component({
  selector: 'sub',
  template: `
<input [(ngModel)]="greeting">
<p>{{greeting}}, World</p>
<button (click)="send()">Send</button>
`,
})
export class SubComponent {
  @Input() greeting: string;

   // rxjs observer
  @Output() onSend = new EventEmitter();

  // no business logic, just event emitting
  send() {
    this.onSend.emit(this.greeting);
  }
}
            </code></pre>
        </section>

        <section>
            <h3>Grenzen</h3>
            <p class="fragment"><em>Besonders bei wachsenden und langlebigen Anwendungen</em></p>
            <ul class="fragment">
                <li>Tendenz zu "Gottkomponenten": Zustand und Logik wandern langsam nach oben in eine einzige Komponente
                <li>Vermischung von Framework und UI-Logik (erschwert Austausch das Frameworks)
                <li>Verteilter, veränderlicher Zustand erschwert Wartbarkeit
                    <ul>
                        <li>Zustand oft nicht klar zuzuordnen</li>
                        <li>In welchem Zustand ist die Anwendung?
                    </ul>
                </li>
                <li>Architektur immer noch unklar
                    <ul>
                        <li>Wo ist Nebenläufigkeit erlaubt?
                        <li>Wie läuft die Initialisierungsphase
                        <li>Wie testet man die Business Logik?
                    </ul>
                </li>
            </ul>
        </section>

        <!--<section>-->
            <!--<a href="https://youtu.be/I7IdS-PbEgI" target="_blank"><img style="height: 600px" src="alan_kay.jpg"></a>-->
            <!--<p><small><a href="https://facebook.github.io/immutable-js/" target="_blank">-->
                <!--https://facebook.github.io/immutable-js/-->
            <!--</a></small></p>-->
        <!--</section>-->

        <section>
            <h3>Nächster Schritt</h3>
            <h2>Redux als Architektur-Muster</h2>
        </section>

        <section>
            <h1>Redux</h1>
            <h2>Zustand wird zentral gehalten, UI-Logik geht aus den Komponenten</h2>
            <h3>Selbst kein Framework, sondern nur ein Muster (wie z.B. MVC)</h3>
        </section>

        <section>
            <h2>Redux ist unabhängig vom Framework</h2>
            <p>Implementierungen existieren für alle wichtigen UI-Frameworks</p>
            <ul>
                <li>React: <a href="http://redux.js.org/docs/basics/UsageWithReact.html" target="_blank">
                    http://redux.js.org/docs/basics/UsageWithReact.html
                </a>
                <li>Angular: <a href="https://github.com/ngrx/store" target="_blank">https://github.com/ngrx/store</a></li>
                <li>Vue: <a href="https://github.com/revue/revue" target="_blank">https://github.com/revue/revue</a>
            </ul>

        </section>

        <section>
            <h2>Redux extrahiert Verwantwortlichkeiten aus UI-Framework</h2>
            <img src="redux-02-extracting-responsibility.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h2>Resultierende Architektur anhand des Redux Musters</h2>
            <img src="redux-03-resulting-redux-architecture.png" style="border:0;box-shadow:0 0 0 0"/>
        </section>

        <section>
            <h3>Ist das nur eine spinnige Idee, oder nutzt das echt jemand?</h3>
            <div class="fragment">
                <a href="https://www.xing.com/messenger" target="_blank">
                <img src="xing-messenger-redux.png">
                </a>
            </div>
        </section>

        <section>
            <h3>Zusammenfassung Redux</h3>
            <ul class="fragment">
                <li>Ein Architektur-Muster für UIs
                <li>Kontroll-/Datenfluss in eine Richtung
                <li>Zustand wandert aus Smart Components in zentralen State
                <li>UI-Logik wandert aus Smart Components in Action-Creators und Reducer
                <li>Nebenläufigkeit nur in Action-Creators
                <li>State ist zentral und immutable
                <li>Business Logik ausschließlich in puren Funktionen - Reducer (beste Testbarkeit)
                <li>Nur Reducer dürfen State verändern
                <li>Initialisierung durch initiale Aktion
            </ul>
        </section>

        <section>
            <h2>Grenzen: SPA Ansatz selbst</h2>
        <!--</section>-->

        <!--<section>-->
            <!--<h3>Probleme von Single-Page Applications</h3>-->
            <ul class="fragment">
                <li>SEO
                <li>First-Page-Impressions
                <li>Preview, z.B.
                    <ul>
                        <li>bei der Vorschau von Suchergebnissen
                        <li> oder dem Teilen von Links durch Social Media
                    </ul>

                </li>
                <!--<li>Progressive Enhancement-->
            </ul>
        </section>

        <section>
            <h3>SPA: First-Page-Impression</h3>
            <div>
                <a href="code/spa/public/index.html" target="_blank">
                    <img src="spa-first-page-impression.png" style="height: 500px;">
                </a>
            </div>
            <p><small>Selbst für eine einfachte Web Application kann das Laden das Aufbauen der Anwendung einige Zeit kosten</small></p>
        </section>

        <section>
            <h2>Nächster Schritt: Universal Web Apps</h2>
        </section>

        <section>
            <h3>Universal Rendering: First-Page-Impression</h3>
            <div>
                <a href="http://localhost:3000/" target="_blank">
                    <img src="universal-first-page-impression.png" style="height: 500px;">
                </a>
            </div>
        </section>

        <section>
            <h3>Universal Rendering</h3>
            <ul class="fragment">
                <li>First-Page-Impression wird auf dem Server gerendert
                <li>Links werden als normale HTML-Links in die Seite gerendert
                <li>Beliebig viele andere Seiten werden ebenfalls statisch gerendert
                <li>Läuft dann (zumindest zum Teil) auch ohne JavaScript
                <li>Code fast 100% geteilt zwischen Client und Server
                <li>serverseitiges Rendering mit <a href="https://nodejs.org" target="_blank">https://nodejs.org</a>
                <li>Neben Markup liefert der Browser ebenso Zustand
                <li>Wird von JS-Frameworks React, Angular und Vue unterstützt
            </ul>
        </section>

        <!--<section>-->
            <!--<h3>Universal Rendering am Beispiel von React</h3>-->
            <!--<div class="fragment">-->
                <!--<img src="universal.png" style="height: 500px;">-->
                <!--<p><small><a target="_blank" href="http://reactbuch.de/">Copyright 2016, D-Punkt, http://reactbuch.de/</a></small></p>-->
            <!--</div>-->
        <!--</section>-->

        <section>
            <a target="_blank"
               href="https://twitter.com/mxstbr/status/776812185276284928">
                <img src="twitter_universal.png">
            </a>
        </section>

        <section>
            <h3>Herausforderungen</h3>
            <ul class="fragment">
                <li>Aller Zustand muss beim serverseitigen Rendering komplett vorliegen
                <li>First Page Impression ungültig: Flackern bei Neurendering im Client
                    <ul>
                        <li>Unterschiedliche Locales auf Server und Client
                        <li>Zeitliche veränderliche Daten (Timestamp, Börsenkurs)
                    </ul>
                </li>
                <li>Auch auf dem Server muss JavaScript laufen (zumindest für das Rendering Layer)
            </ul>
        </section>

        <section>
            <h3>Integration mit Microservices</h3>
            <ul>
                <li class="fragment">Integration im Browser
                    <ul>
                        <li>Anwendung ist in logische Module aufgeteilt, die als ganze Anwendung zusammen laufen
                        <li>Pro Seite eine Anwendung, kann Komponenten aus andern Modulen integrieten
                        <!--<li>Nachladen von Modulen on-demand aus einem Build problemlos möglich-->
                        <li>"Echt" getrennte Anwendung über iFrame und EventBus
                    </ul>
                </li>
                <li class="fragment">Integration über Links, die eine neue Anwendung öffnen und die alte ersetzen
                    <ul>
                        <li>jedes Modul ist eine eigene SPA Anwendung
                        <li>erlaubt Vertikalen wie eine klassische Web-App
                        <li>Modul-Wechsel setzt Zustand zurück wenn nicht explizit übertragen
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h3>Was ist mit meiner guten alten Web-Anwendung passiert?</h3>
            <p class="fragment">Ist das nicht alles zu kompliziert?</p>
            <ul>
                <li class="fragment">Klassische, serverseitig gerenderte Anwendungen,
                    sind häufig wirklich einfacher und besser modularisierbar
                <li class="fragment">Hohe Anforderungen an UX und UI sind allerdings nicht mit sinnvollem Aufwand mit klassischen Web-Anwendungen umsetzbar
                <li class="fragment">die Komplexitäten einer Single Page App entspringen aus diesen Anforderungen an UX und UI
                <li class="fragment"><strong>Das Grundproblem ist der Widerspruch zwischen ganzheitlicher UX und Aufteilung in Komponenten / Module / Teams</strong>
            </ul>
        </section>

        <!--<section>-->
            <!--<h3>Welcher Anforderungen kommen durch das Web hinzu?</h3>-->
            <!--<ul>-->
                <!--<li class="fragment">Wie kann man wartbar JavaScript entwickeln?-->
                <!--<li class="fragment">Wie geht man mit der schnellen Entwicklung der Web-Frameworks um?-->
                <!--<li class="fragment">JavaScript im Browser, aber meist nicht auch auf dem Server - -->
                    <!--wie bekommt man damit eine einheitliche Architektur hin?-->
            <!--</ul>-->
        <!--</section>-->

        <section>
            <h3>Legenden und Mythen #1: Single Page Applications (SPA)</h3>
            <ul>
                <li class="fragment"><strong>In SPAs kann ich keine Links teilen und auch nicht sinnvoll verlinken: </strong>
                    <span class="fragment">Links werden im Browser aufgelöst und geroutet</span>
                <li class="fragment"><strong>Back-Button geht nicht: </strong><span class="fragment">siehe oben</span>
                <li class="fragment"><strong>SPA hat immer eine schlechte First Page Impression: </strong><span class="fragment">Universal App oder Code-Splitting hilft</span>
                <li class="fragment"><strong>SPA ist unstrukturierter Monolith: </strong>
                <span class="fragment">Trennung, Isolation in Module und Teams ist mit gezeigten Ansätzen möglich</span>
                <li class="fragment"><strong>HTML/HTTP sind langlebig, Investition in SPA-Frameworks nicht lohnend, veraltet innerhalb einer Woche: </strong>
                <span class="fragment">Framework-Krieg ist wahrscheinlich beendet, Business relevante Teile ohnehin außerhalb des SPA-Webframeworks</span>
            </ul>
        </section>

        <section>
            <h3>Legenden und Mythen #2: JavaScript</h3>
            <p class="fragment">Ist JavaScript-Code nicht unwartbar?</p>
            <ul>
                <li class="fragment"><strong>keine Lesbarkeit: </strong><span class="fragment">moderner JavaScript-Code ist auf Python-Niveau, JSDoc ist Standard</span>
                <li class="fragment"><strong>keine Analysierbarkeit: </strong><span class="fragment">
                wird durch zusätzliche mächtige Typensysteme TypeScript oder Flow erlaubt</span>
                <li class="fragment"><strong>kein Refactoring: </strong><span class="fragment">folgt aus Analysierbarkeit</span>
                <li class="fragment"><strong>keine Testbarkeit: </strong><span class="fragment">gezeigte Ansätze erlauben allerbeste Testbarkeit aller Teile</span>
                <li class="fragment"><strong>keine Wiederverwendung: </strong><span class="fragment">
                Dumb Componentes jederzeit wiederverwendbar, bei Smart Components nicht sinnvoll</span>
                <li class="fragment"><strong>keine Möglichkeit zur Strukturieren: </strong>
                <span class="fragment">Das moderne JavaScript Modul-System ist mächtig
                    und erlaubt Strukturierung wie in Java</span>
            </ul>
        </section>

        <section>
            <h3>The Doctor is In</h3>
            <small>
            <table>
                <tr>
                    <th></th><th>Wissen</th><th>Anforderungen</th><th>A-Z</th>
                </tr>
                <tr>
                    <th>20</th>
                    <td>Muss man für SPAs und Universal Apps JavaScript programmieren?</td>
                    <td>Warum soll man überhaupt JavaScript machen?
                    </td>
                    <td>Muss ich immer wählen zwischen Frontend-Monolithen odert UX Katastrophe?
                    </td>
                </tr>
                <tr>
                    <th>40</th>
                    <td>Wie realisiert man komplexe UI-Komponenten (ala TreeGrid)?</td>
                    <td>Sollte ich nicht jede SPA als Universal App schreiben?
                    </td>
                    <td>Widersprechen SPAs nicht der Grundidee es Webs?
                    </td>
                </tr>
                <tr>
                    <th>60</th>

                    <td><b>Risiko: Frage eurer Wahl</b></td>
                    <td><b>Risiko: Frage eurer Wahl</b></td>
                    <td><b>Risiko: Frage eurer Wahl</b></td>
                </tr>
                <tr>
                    <th>80</th>
                    <td>Wie schneide ich Module in einer SPA? Geht das mit DDD Aggregate Root?
                    </td>
                    <td>Wann passt eine klassische WebApp besser als eine SPA?
                    </td>
                    <td>Wieso funktioniert für SPAs kein Schichtenmodell?
                    </td>
                </tr>
                <tr>
                    <th>100</th>
                    <td>Was kann man retten, wenn man das UI-Framework wechselt?</td>
                    <td>Wie kann ich sicher sein, dass ich den richtigen Architektur-Ansatz habe?</td>
                    <td>Muss ich das immer so machen, oder kann ich auch Web Components nutzen?</td>
                </tr>
            </table></small>
            <p><small>
                <a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>,
                <a href="http://bit.ly/architektur-herbstcampus">
                http://bit.ly/architektur-herbstcampus</a></small></p>
        </section>

    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>
<script>
    if (window.location.hostname.indexOf('localhost') !== -1) {
    } else {
        // only applies to public version
        $('.preparation').remove();
    }
    Reveal.addEventListener( 'ready', function( event ) {
        if (window.location.hostname.indexOf('localhost') !== -1) {
            // only applies to presentation version
            Reveal.configure({ controls: false });
        } else {
            // only applies to public version
            $('.fragment').removeClass('fragment');
        }
        // applies to all versions
        $('code').addClass('line-numbers');
    } );
</script>


<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
